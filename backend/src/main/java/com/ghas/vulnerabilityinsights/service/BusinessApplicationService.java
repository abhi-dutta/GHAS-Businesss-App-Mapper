package com.ghas.vulnerabilityinsights.service;

import com.ghas.vulnerabilityinsights.dto.*;
import com.ghas.vulnerabilityinsights.model.BusinessApplication;
import com.ghas.vulnerabilityinsights.model.RepositoryMapping;
import com.ghas.vulnerabilityinsights.repository.BusinessApplicationRepository;
import com.ghas.vulnerabilityinsights.repository.RepositoryMappingRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service for managing business applications and their repository mappings.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class BusinessApplicationService {
    
    private final BusinessApplicationRepository businessApplicationRepository;
    private final RepositoryMappingRepository repositoryMappingRepository;
    private final GitHubApiService gitHubApiService;
    
    /**
     * Create a new business application with repository mappings.
     */
    @Transactional
    public BusinessApplicationDto createBusinessApplication(CreateBusinessApplicationDto createDto) {
        log.info("Creating business application: {}", createDto.getName());
        
        // Check if business application already exists
        Optional<BusinessApplication> existingApp = businessApplicationRepository
                .findByNameAndOrganization(createDto.getName(), createDto.getOrganization());
        
        if (existingApp.isPresent()) {
            throw new RuntimeException("Business application with name '" + createDto.getName() + 
                                     "' already exists in organization '" + createDto.getOrganization() + "'");
        }
        
        // Create business application
        BusinessApplication businessApp = BusinessApplication.builder()
                .name(createDto.getName())
                .description(createDto.getDescription())
                .organization(createDto.getOrganization())
                .businessOwnerEmail(createDto.getBusinessOwnerEmail())
                .build();
        
        BusinessApplication savedApp = businessApplicationRepository.save(businessApp);
        
        // Create repository mappings
        List<RepositoryMapping> repositoryMappings = createDto.getRepositoryNames().stream()
                .map(repoName -> RepositoryMapping.builder()
                        .businessApplication(savedApp)
                        .repositoryName(repoName)
                        .repositoryUrl("https://github.com/" + createDto.getOrganization() + "/" + repoName)
                        .repositoryFullName(createDto.getOrganization() + "/" + repoName)
                        .build())
                .collect(Collectors.toList());
        
        repositoryMappingRepository.saveAll(repositoryMappings);
        
        return mapToDto(savedApp, repositoryMappings);
    }
    
    /**
     * Get all business applications for an organization.
     */
    public List<BusinessApplicationDto> getBusinessApplications(String organization) {
        log.info("Fetching business applications for organization: {}", organization);
        
        List<BusinessApplication> apps = businessApplicationRepository.findByOrganizationWithRepositories(organization);
        
        return apps.stream()
                .map(app -> mapToDto(app, app.getRepositories()))
                .collect(Collectors.toList());
    }
    
    /**
     * Get business application by ID.
     */
    public Optional<BusinessApplicationDto> getBusinessApplicationById(Long id) {
        log.info("Fetching business application with ID: {}", id);
        
        return businessApplicationRepository.findById(id)
                .map(app -> {
                    List<RepositoryMapping> mappings = repositoryMappingRepository.findByBusinessApplicationId(id);
                    return mapToDto(app, mappings);
                });
    }
    
    /**
     * Update business application.
     */
    @Transactional
    public BusinessApplicationDto updateBusinessApplication(Long id, CreateBusinessApplicationDto updateDto) {
        log.info("Updating business application with ID: {}", id);
        
        BusinessApplication existingApp = businessApplicationRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Business application not found with ID: " + id));
        
        // Update business application fields
        existingApp.setName(updateDto.getName());
        existingApp.setDescription(updateDto.getDescription());
        existingApp.setBusinessOwnerEmail(updateDto.getBusinessOwnerEmail());
        
        BusinessApplication updatedApp = businessApplicationRepository.save(existingApp);
        
        // Update repository mappings
        repositoryMappingRepository.deleteByBusinessApplicationId(id);
        
        List<RepositoryMapping> newMappings = updateDto.getRepositoryNames().stream()
                .map(repoName -> RepositoryMapping.builder()
                        .businessApplication(updatedApp)
                        .repositoryName(repoName)
                        .repositoryUrl("https://github.com/" + updateDto.getOrganization() + "/" + repoName)
                        .repositoryFullName(updateDto.getOrganization() + "/" + repoName)
                        .build())
                .collect(Collectors.toList());
        
        repositoryMappingRepository.saveAll(newMappings);
        
        return mapToDto(updatedApp, newMappings);
    }
    
    /**
     * Delete business application.
     */
    @Transactional
    public void deleteBusinessApplication(Long id) {
        log.info("Deleting business application with ID: {}", id);
        
        if (!businessApplicationRepository.existsById(id)) {
            throw new RuntimeException("Business application not found with ID: " + id);
        }
        
        businessApplicationRepository.deleteById(id);
    }
    
    /**
     * Get statistics for business applications.
     */
    public BusinessApplicationStatsDto getBusinessApplicationStats(String organization) {
        log.info("Fetching business application statistics for organization: {}", organization);
        
        long totalApps = businessApplicationRepository.countByOrganization(organization);
        List<String> distinctRepos = repositoryMappingRepository.findDistinctRepositoryNamesByOrganization(organization);
        
        return BusinessApplicationStatsDto.builder()
                .totalApplications(totalApps)
                .totalRepositories(distinctRepos.size())
                .repositories(distinctRepos)
                .build();
    }
    
    /**
     * Get vulnerability data for business applications.
     */
    public List<BusinessApplicationVulnerabilityDto> getBusinessApplicationVulnerabilityData(String organization, String token) {
        log.info("Fetching vulnerability data for business applications in organization: {}", organization);
        
        List<BusinessApplication> apps = businessApplicationRepository.findByOrganizationWithRepositories(organization);
        
        return apps.stream()
                .map(app -> {
                    List<RepositoryMapping> mappings = repositoryMappingRepository.findByBusinessApplicationId(app.getId());
                    
                    // Calculate vulnerability stats for this application
                    BusinessApplicationVulnerabilityDto.VulnerabilityStats vulnStats = calculateVulnerabilityStats(
                            mappings, organization, token);
                    
                    return BusinessApplicationVulnerabilityDto.builder()
                            .id(app.getId())
                            .name(app.getName())
                            .organization(app.getOrganization())
                            .businessOwnerEmail(app.getBusinessOwnerEmail())
                            .repositoryCount(mappings.size())
                            .vulnerabilities(vulnStats)
                            .createdAt(app.getCreatedAt())
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Get vulnerability data for business applications (including all states for debugging).
     */
    public List<BusinessApplicationVulnerabilityDto> getBusinessApplicationVulnerabilityDataDebug(String organization, String token) {
        log.info("Fetching vulnerability data (debug mode) for business applications in organization: {}", organization);
        
        List<BusinessApplication> apps = businessApplicationRepository.findByOrganizationWithRepositories(organization);
        
        return apps.stream()
                .map(app -> {
                    List<RepositoryMapping> mappings = repositoryMappingRepository.findByBusinessApplicationId(app.getId());
                    
                    // Calculate vulnerability stats for this application (including all states)
                    BusinessApplicationVulnerabilityDto.VulnerabilityStats vulnStats = calculateVulnerabilityStatsDebug(
                            mappings, organization, token);
                    
                    return BusinessApplicationVulnerabilityDto.builder()
                            .id(app.getId())
                            .name(app.getName())
                            .organization(app.getOrganization())
                            .businessOwnerEmail(app.getBusinessOwnerEmail())
                            .repositoryCount(mappings.size())
                            .vulnerabilities(vulnStats)
                            .createdAt(app.getCreatedAt())
                            .build();
                })
                .collect(Collectors.toList());
    }

    /**
     * Get vulnerability trend data for an organization.
     */
    public List<VulnerabilityTrendDto> getVulnerabilityTrend(String organization, String token) {
        log.info("Fetching vulnerability trend data for organization: {}", organization);

        List<RepositoryMapping> allMappings = repositoryMappingRepository.findByBusinessApplicationOrganization(organization);
        List<String> uniqueRepoNames = allMappings.stream()
                .map(RepositoryMapping::getRepositoryName)
                .distinct()
                .collect(Collectors.toList());

        log.debug("Found {} unique repositories for trend analysis", uniqueRepoNames.size());

        List<CodeScanningAlertDto> allAlerts = Flux.fromIterable(uniqueRepoNames)
                .flatMap(repoName -> 
                    gitHubApiService.getCodeScanningAlerts(organization, repoName, token)
                        .flatMapMany(Flux::fromIterable) // Use flatMapMany to convert Mono<List<T>> to Flux<T>
                        .doOnError(e -> log.warn("Failed to fetch or process code scanning alerts for repo '{}'. The repository might not have code scanning enabled or may have no alerts. Skipping.", repoName))
                        .onErrorResume(e -> Flux.empty()) // On error, log and continue with an empty stream for this repo
                )
                .collectList()
                .block();

        if (allAlerts == null || allAlerts.isEmpty()) {
            log.warn("No code scanning alerts found for organization {}", organization);
            return List.of();
        }

        log.info("Processing {} total alerts for trend analysis", allAlerts.size());

        // Group alerts by month, then by severity
        Map<String, Map<String, Long>> trendMap = allAlerts.stream()
                .collect(Collectors.groupingBy(
                        alert -> alert.getCreatedAt().format(DateTimeFormatter.ofPattern("yyyy-MM")), // Group by year-month
                        Collectors.groupingBy(
                                alert -> getSeverity(alert.getRule()), 
                                Collectors.counting()
                        )
                ));

        // Convert to DTOs and sort by month
        return trendMap.entrySet().stream()
                .sorted(Map.Entry.comparingByKey())
                .map(entry -> {
                    String month = entry.getKey();
                    Map<String, Integer> severities = entry.getValue().entrySet().stream()
                            .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().intValue()));
                    return new VulnerabilityTrendDto(month, severities);
                })
                .collect(Collectors.toList());
    }

    /**
     * Calculate vulnerability statistics for a business application (debug version - includes all states).
     */
    private BusinessApplicationVulnerabilityDto.VulnerabilityStats calculateVulnerabilityStatsDebug(
            List<RepositoryMapping> mappings, String organization, String token) {
        
        log.info("Calculating vulnerability stats (debug mode) for {} repositories in organization: {}", mappings.size(), organization);

        List<CodeScanningAlertDto> allAlerts = Flux.fromIterable(mappings)
                .flatMap(mapping -> gitHubApiService.getCodeScanningAlerts(organization, mapping.getRepositoryName(), token))
                .flatMap(Flux::fromIterable)
                .collectList()
                .block();

        if (allAlerts == null) {
            return buildEmptyStats();
        }

        log.info("Found {} alerts (all states) for {} repositories", allAlerts.size(), mappings.size());

        int criticalVulns = 0;
        int highVulns = 0;
        int mediumVulns = 0;
        int lowVulns = 0;

        for (CodeScanningAlertDto alert : allAlerts) {
            switch (getSeverity(alert.getRule())) {
                case "critical": criticalVulns++; break;
                case "high": highVulns++; break;
                case "medium": mediumVulns++; break;
                case "low": lowVulns++; break;
            }
        }
        
        return BusinessApplicationVulnerabilityDto.VulnerabilityStats.builder()
                .total(allAlerts.size())
                .critical(criticalVulns)
                .high(highVulns)
                .medium(mediumVulns)
                .low(lowVulns)
                .build();
    }

    /**
     * Calculate vulnerability statistics for a business application.
     */
    private BusinessApplicationVulnerabilityDto.VulnerabilityStats calculateVulnerabilityStats(
            List<RepositoryMapping> mappings, String organization, String token) {

        log.info("Calculating vulnerability stats for {} repositories in organization: {}", mappings.size(), organization);

        List<CodeScanningAlertDto> openAlerts = Flux.fromIterable(mappings)
                .flatMap(mapping -> gitHubApiService.getCodeScanningAlerts(organization, mapping.getRepositoryName(), token))
                .flatMap(Flux::fromIterable)
                .filter(alert -> "open".equalsIgnoreCase(alert.getState()))
                .collectList()
                .block();

        if (openAlerts == null) {
            return buildEmptyStats();
        }

        log.info("Found {} open alerts for {} repositories", openAlerts.size(), mappings.size());

        int criticalVulns = 0;
        int highVulns = 0;
        int mediumVulns = 0;
        int lowVulns = 0;

        for (CodeScanningAlertDto alert : openAlerts) {
            switch (getSeverity(alert.getRule())) {
                case "critical": criticalVulns++; break;
                case "high": highVulns++; break;
                case "medium": mediumVulns++; break;
                case "low": lowVulns++; break;
            }
        }
        
        return BusinessApplicationVulnerabilityDto.VulnerabilityStats.builder()
                .total(openAlerts.size())
                .critical(criticalVulns)
                .high(highVulns)
                .medium(mediumVulns)
                .low(lowVulns)
                .build();
    }

    private String getSeverity(CodeScanningAlertDto.Rule rule) {
        if (rule == null) {
            return "medium"; // Default severity
        }

        // Prioritize the more specific security severity level if available
        String securitySeverity = rule.getSecuritySeverityLevel();
        if (securitySeverity != null && !securitySeverity.trim().isEmpty()) {
            return securitySeverity.toLowerCase();
        }

        // Fallback to the general severity level
        String severity = rule.getSeverity();
        if (severity != null && !severity.trim().isEmpty()) {
            switch (severity.toLowerCase()) {
                case "critical":
                case "error":
                    return "critical";
                case "high":
                    return "high";
                case "medium":
                case "warning":
                    return "medium";
                case "low":
                case "note":
                case "info":
                    return "low";
                default:
                    return "medium";
            }
        }

        return "medium"; // Default if neither is present
    }

    private BusinessApplicationVulnerabilityDto.VulnerabilityStats buildEmptyStats() {
        return BusinessApplicationVulnerabilityDto.VulnerabilityStats.builder()
                .total(0).critical(0).high(0).medium(0).low(0).build();
    }

    /**
     * Map BusinessApplication entity to DTO.
     */
    private BusinessApplicationDto mapToDto(BusinessApplication app, List<RepositoryMapping> mappings) {
        List<RepositoryMappingDto> repositoryDtos = mappings.stream()
                .map(mapping -> RepositoryMappingDto.builder()
                        .id(mapping.getId())
                        .repositoryName(mapping.getRepositoryName())
                        .repositoryUrl(mapping.getRepositoryUrl())
                        .repositoryFullName(mapping.getRepositoryFullName())
                        .createdAt(mapping.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
        
        return BusinessApplicationDto.builder()
                .id(app.getId())
                .name(app.getName())
                .description(app.getDescription())
                .organization(app.getOrganization())
                .businessOwnerEmail(app.getBusinessOwnerEmail())
                .createdAt(app.getCreatedAt())
                .repositories(repositoryDtos)
                .build();
    }
    
    /**
     * DTO for business application statistics.
     */
    @lombok.Data
    @lombok.Builder
    @lombok.NoArgsConstructor
    @lombok.AllArgsConstructor
    public static class BusinessApplicationStatsDto {
        private long totalApplications;
        private long totalRepositories;
        private List<String> repositories;
    }
}
