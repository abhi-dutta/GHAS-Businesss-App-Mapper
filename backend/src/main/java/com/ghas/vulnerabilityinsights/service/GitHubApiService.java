package com.ghas.vulnerabilityinsights.service;

import com.ghas.vulnerabilityinsights.dto.CodeScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.DependabotAlertDto;
import com.ghas.vulnerabilityinsights.dto.GitHubRepositoryDto;
import com.ghas.vulnerabilityinsights.dto.SecretScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.GitHubUserDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Service for interacting with GitHub API.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class GitHubApiService {
    
    private final WebClient webClient;
    
    @Value("${github.api.base-url:https://api.github.com}")
    private String githubApiBaseUrl;
    
    /**
     * Validate GitHub Personal Access Token.
     */
    public Mono<Boolean> validateToken(String token) {
        log.debug("Validating GitHub token for user endpoint");
        
        return webClient.get()
                .uri("https://api.github.com/user")
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(Object.class)
                .map(response -> {
                    log.debug("GitHub token validation successful");
                    return true;
                })
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.warn("GitHub token validation failed with status: {} - {}", 
                            ex.getStatusCode(), ex.getMessage());
                    return Mono.just(false);
                })
                .onErrorResume(Exception.class, ex -> {
                    log.error("Unexpected error during token validation: {}", ex.getMessage());
                    return Mono.just(false);
                });
    }
    
    /**
     * Get all repositories from a GitHub organization.
     */
    @Cacheable(value = "orgRepositories", key = "#orgName + '_' + #token")
    public Mono<List<GitHubRepositoryDto>> getOrganizationRepositories(String orgName, String token) {
        return fetchAllRepositories(orgName, token, 1, new ArrayList<>());
    }
    
    /**
     * Get all repositories from a GitHub organization with enriched language data.
     */
    public Mono<List<GitHubRepositoryDto>> getOrganizationRepositoriesWithLanguages(String orgName, String token) {
        return getOrganizationRepositories(orgName, token)
                .flatMap(repositories -> {
                    // Fetch all repositories with language data
                    if (repositories.isEmpty()) {
                        return Mono.just(repositories);
                    }
                    
                    // Process repositories in batches to manage rate limiting
                    int batchSize = 10;
                    List<List<GitHubRepositoryDto>> batches = new ArrayList<>();
                    
                    for (int i = 0; i < repositories.size(); i += batchSize) {
                        int end = Math.min(i + batchSize, repositories.size());
                        batches.add(repositories.subList(i, end));
                    }
                    
                    // Process batches sequentially to avoid overwhelming the API
                    return Flux.fromIterable(batches)
                            .concatMap(batch -> {
                                List<Mono<GitHubRepositoryDto>> enrichedRepos = batch.stream()
                                        .map(repo -> enrichRepositoryWithLanguages(orgName, repo, token))
                                        .collect(java.util.stream.Collectors.toList());
                                
                                return Mono.zip(enrichedRepos, objects -> {
                                    List<GitHubRepositoryDto> result = new ArrayList<>();
                                    for (Object obj : objects) {
                                        result.add((GitHubRepositoryDto) obj);
                                    }
                                    return result;
                                });
                            })
                            .collectList()
                            .map(batchResults -> {
                                List<GitHubRepositoryDto> allResults = new ArrayList<>();
                                for (List<GitHubRepositoryDto> batchResult : batchResults) {
                                    allResults.addAll(batchResult);
                                }
                                return allResults;
                            });
                })
                .onErrorResume(error -> {
                    log.error("Failed to fetch repositories with languages for org {}: {}", orgName, error.getMessage());
                    // Fallback to basic repository data
                    return getOrganizationRepositories(orgName, token);
                });
    }
    
    /**
     * Enrich a single repository with language data.
     */
    private Mono<GitHubRepositoryDto> enrichRepositoryWithLanguages(String orgName, GitHubRepositoryDto repo, String token) {
        return getRepositoryLanguages(orgName, repo.getName(), token)
                .map(languages -> {
                    repo.setLanguages(languages);
                    return repo;
                })
                .onErrorResume(error -> {
                    log.warn("Failed to fetch languages for {}/{}: {}", orgName, repo.getName(), error.getMessage());
                    repo.setLanguages(new HashMap<>());
                    return Mono.just(repo);
                });
    }
    
    /**
     * Recursively fetch all repositories from an organization (handles pagination).
     */
    private Mono<List<GitHubRepositoryDto>> fetchAllRepositories(String orgName, String token, int page, List<GitHubRepositoryDto> allRepos) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("https")
                        .host("api.github.com")
                        .path("/orgs/{org}/repos")
                        .queryParam("per_page", 100)
                        .queryParam("page", page)
                        .queryParam("sort", "updated")
                        .queryParam("direction", "desc")
                        .build(orgName))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<GitHubRepositoryDto>>() {})
                .flatMap(repos -> {
                    // Debug: Log the first repository to see what fields we're getting
                    if (!repos.isEmpty()) {
                        GitHubRepositoryDto firstRepo = repos.get(0);
                        log.info("Sample repository data - Name: {}, htmlUrl: {}", 
                                firstRepo.getName(), firstRepo.getHtmlUrl());
                        log.debug("Full repository object: {}", firstRepo);
                    }
                    
                    if (repos.isEmpty()) {
                        return Mono.just(allRepos);
                    }
                    
                    allRepos.addAll(repos);
                    
                    // If we got 100 repos, there might be more on the next page
                    if (repos.size() == 100) {
                        return fetchAllRepositories(orgName, token, page + 1, allRepos);
                    } else {
                        return Mono.just(allRepos);
                    }
                })
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Error fetching repositories for organization {}: {}", orgName, ex.getMessage());
                    if (ex.getStatusCode() == HttpStatus.NOT_FOUND) {
                        return Mono.error(new RuntimeException("Organization not found: " + orgName));
                    } else if (ex.getStatusCode() == HttpStatus.FORBIDDEN) {
                        return Mono.error(new RuntimeException("Access denied. Please check your GitHub token permissions."));
                    }
                    return Mono.error(new RuntimeException("Failed to fetch repositories: " + ex.getMessage()));
                });
    }
    
    /**
     * Get vulnerability alerts for a repository.
     */
    public Mono<Object> getVulnerabilityAlerts(String orgName, String repoName, String token) {
        return webClient.get()
                .uri("https://api.github.com/repos/{owner}/{repo}/vulnerability-alerts", orgName, repoName)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(Object.class)
                .onErrorReturn(WebClientResponseException.class, null);
    }
    
    /**
     * Get security advisories for a repository.
     */
    public Mono<Object> getSecurityAdvisories(String orgName, String repoName, String token) {
        return webClient.get()
                .uri("https://api.github.com/repos/{owner}/{repo}/security-advisories", orgName, repoName)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(Object.class)
                .onErrorReturn(WebClientResponseException.class, null);
    }
    
    /**
     * Get code scanning alerts for a repository.
     */
    public Mono<List<CodeScanningAlertDto>> getCodeScanningAlerts(String orgName, String repoName, String token) {
        log.debug("Fetching code scanning alerts for repository: {}/{}", orgName, repoName);
        
        return webClient.get()
                .uri("https://api.github.com/repos/{owner}/{repo}/code-scanning/alerts", orgName, repoName)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<CodeScanningAlertDto>>() {})
                .doOnSuccess(response -> log.debug("Successfully fetched code scanning alerts for {}/{}", orgName, repoName))
                .doOnError(error -> {
                    if (error instanceof WebClientResponseException) {
                        WebClientResponseException webEx = (WebClientResponseException) error;
                        log.error("Failed to fetch code scanning alerts for {}/{}: HTTP {} - {}", 
                                orgName, repoName, webEx.getStatusCode(), webEx.getResponseBodyAsString());
                    } else {
                        log.error("Failed to fetch code scanning alerts for {}/{}: {}", orgName, repoName, error.getMessage());
                    }
                })
                .onErrorReturn(new ArrayList<>());
    }

    /**
     * Get dependabot alerts for a repository.
     */
    public Mono<List<DependabotAlertDto>> getDependabotAlerts(String orgName, String repoName, String token) {
        log.debug("Fetching dependabot alerts for repository: {}/{}", orgName, repoName);
        
        return webClient.get()
                .uri("https://api.github.com/repos/{owner}/{repo}/dependabot/alerts", orgName, repoName)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<DependabotAlertDto>>() {})
                .doOnSuccess(response -> log.debug("Successfully fetched dependabot alerts for {}/{}", orgName, repoName))
                .doOnError(error -> {
                    if (error instanceof WebClientResponseException) {
                        WebClientResponseException webEx = (WebClientResponseException) error;
                        log.error("Failed to fetch dependabot alerts for {}/{}: HTTP {} - {}", 
                                orgName, repoName, webEx.getStatusCode(), webEx.getResponseBodyAsString());
                    } else {
                        log.error("Failed to fetch dependabot alerts for {}/{}: {}", orgName, repoName, error.getMessage());
                    }
                })
                .onErrorReturn(new ArrayList<>());
    }

    /**
     * Get secret scanning alerts for a repository.
     */
    public Mono<List<SecretScanningAlertDto>> getSecretScanningAlerts(String orgName, String repoName, String token) {
        log.debug("Fetching secret scanning alerts for repository: {}/{}", orgName, repoName);
        
        return webClient.get()
                .uri("https://api.github.com/repos/{owner}/{repo}/secret-scanning/alerts", orgName, repoName)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<SecretScanningAlertDto>>() {})
                .doOnSuccess(response -> log.debug("Successfully fetched secret scanning alerts for {}/{}", orgName, repoName))
                .doOnError(error -> {
                    if (error instanceof WebClientResponseException) {
                        WebClientResponseException webEx = (WebClientResponseException) error;
                        log.error("Failed to fetch secret scanning alerts for {}/{}: HTTP {} - {}", 
                                orgName, repoName, webEx.getStatusCode(), webEx.getResponseBodyAsString());
                    } else {
                        log.error("Failed to fetch secret scanning alerts for {}/{}: {}", orgName, repoName, error.getMessage());
                    }
                })
                .onErrorReturn(new ArrayList<>());
    }

    /**
     * Get organization-level code scanning alerts.
     * This endpoint provides all code scanning alerts across the organization.
     */
    public Mono<List<CodeScanningAlertDto>> getOrganizationCodeScanningAlerts(String orgName, String token) {
        log.debug("Fetching organization-level code scanning alerts for: {}", orgName);
        
        return fetchAllOrganizationCodeScanningAlerts(orgName, token, 1, new ArrayList<>());
    }
    
    /**
     * Recursively fetch all organization-level code scanning alerts (handles pagination).
     */
    private Mono<List<CodeScanningAlertDto>> fetchAllOrganizationCodeScanningAlerts(String orgName, String token, int page, List<CodeScanningAlertDto> allAlerts) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("https")
                        .host("api.github.com")
                        .path("/orgs/{org}/code-scanning/alerts")
                        .queryParam("per_page", 100)
                        .queryParam("page", page)
                        .queryParam("state", "open")
                        .build(orgName))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<CodeScanningAlertDto>>() {})
                .flatMap(alerts -> {
                    if (alerts.isEmpty()) {
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(alerts);
                    
                    // If we got 100 alerts, there might be more on the next page
                    if (alerts.size() == 100) {
                        return fetchAllOrganizationCodeScanningAlerts(orgName, token, page + 1, allAlerts);
                    } else {
                        return Mono.just(allAlerts);
                    }
                })
                .doOnSuccess(response -> log.debug("Successfully fetched {} organization code scanning alerts for {}", allAlerts.size(), orgName))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Error fetching organization code scanning alerts for {}: {}", orgName, ex.getMessage());
                    return Mono.just(new ArrayList<>());
                });
    }

    /**
     * Get organization-level secret scanning alerts.
     */
    public Mono<List<SecretScanningAlertDto>> getOrganizationSecretScanningAlerts(String orgName, String token) {
        log.debug("Fetching organization-level secret scanning alerts for: {}", orgName);
        
        return fetchAllOrganizationSecretScanningAlerts(orgName, token, 1, new ArrayList<>());
    }
    
    /**
     * Recursively fetch all organization-level secret scanning alerts (handles pagination).
     */
    private Mono<List<SecretScanningAlertDto>> fetchAllOrganizationSecretScanningAlerts(String orgName, String token, int page, List<SecretScanningAlertDto> allAlerts) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("https")
                        .host("api.github.com")
                        .path("/orgs/{org}/secret-scanning/alerts")
                        .queryParam("per_page", 100)
                        .queryParam("page", page)
                        .queryParam("state", "open")
                        .build(orgName))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<SecretScanningAlertDto>>() {})
                .flatMap(alerts -> {
                    if (alerts.isEmpty()) {
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(alerts);
                    
                    // If we got 100 alerts, there might be more on the next page
                    if (alerts.size() == 100) {
                        return fetchAllOrganizationSecretScanningAlerts(orgName, token, page + 1, allAlerts);
                    } else {
                        return Mono.just(allAlerts);
                    }
                })
                .doOnSuccess(response -> log.debug("Successfully fetched {} organization secret scanning alerts for {}", allAlerts.size(), orgName))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Error fetching organization secret scanning alerts for {}: {}", orgName, ex.getMessage());
                    return Mono.just(new ArrayList<>());
                });
    }

    /**
     * Get organization-level dependabot alerts.
     */
    public Mono<List<DependabotAlertDto>> getOrganizationDependabotAlerts(String orgName, String token) {
        log.debug("Fetching organization-level dependabot alerts for: {}", orgName);
        
        return fetchAllOrganizationDependabotAlerts(orgName, token, 1, new ArrayList<>());
    }
    
    /**
     * Recursively fetch all organization-level dependabot alerts (handles pagination).
     */
    private Mono<List<DependabotAlertDto>> fetchAllOrganizationDependabotAlerts(String orgName, String token, int page, List<DependabotAlertDto> allAlerts) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("https")
                        .host("api.github.com")
                        .path("/orgs/{org}/dependabot/alerts")
                        .queryParam("per_page", 100)
                        .queryParam("page", page)
                        .queryParam("state", "open")
                        .build(orgName))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<DependabotAlertDto>>() {})
                .flatMap(alerts -> {
                    if (alerts.isEmpty()) {
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(alerts);
                    
                    // If we got 100 alerts, there might be more on the next page
                    if (alerts.size() == 100) {
                        return fetchAllOrganizationDependabotAlerts(orgName, token, page + 1, allAlerts);
                    } else {
                        return Mono.just(allAlerts);
                    }
                })
                .doOnSuccess(response -> log.debug("Successfully fetched {} organization dependabot alerts for {}", allAlerts.size(), orgName))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Error fetching organization dependabot alerts for {}: {}", orgName, ex.getMessage());
                    return Mono.just(new ArrayList<>());
                });
    }

    /**
     * Get detailed user information from GitHub.
     */
    public Mono<GitHubUserDto> getUserDetails(String username, String token) {
        log.debug("Fetching user details for: {}", username);
        
        return webClient.get()
                .uri("https://api.github.com/users/{username}", username)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(GitHubUserDto.class)
                .doOnSuccess(response -> log.debug("Successfully fetched user details for {}", username))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.warn("Failed to fetch user details for {}: {}", username, ex.getMessage());
                    return Mono.empty();
                });
    }

    /**
     * Get languages for a repository.
     */
    public Mono<Map<String, Integer>> getRepositoryLanguages(String owner, String repo, String token) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .scheme("https")
                        .host("api.github.com")
                        .path("/repos/{owner}/{repo}/languages")
                        .build(owner, repo))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Map<String, Integer>>() {})
                .doOnSuccess(response -> log.debug("Successfully fetched languages for {}/{}", owner, repo))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.warn("Failed to fetch languages for {}/{}: {}", owner, repo, ex.getMessage());
                    return Mono.just(new HashMap<>());
                });
    }
}
