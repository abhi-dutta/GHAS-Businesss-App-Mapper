package com.ghas.vulnerabilityinsights.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ghas.vulnerabilityinsights.model.EnterpriseJob;
import com.ghas.vulnerabilityinsights.repository.EnterpriseJobRepository;
import com.ghas.vulnerabilityinsights.dto.JobProgressUpdateDto;
import com.ghas.vulnerabilityinsights.dto.CodeScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.SecretScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.DependabotAlertDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.List;
import java.util.ArrayList;

@Service
@RequiredArgsConstructor
@Slf4j
public class AsyncJobProcessor {

    private final EnterpriseJobRepository jobRepository;
    private final WebSocketMessageService webSocketService;
    private final ObjectMapper objectMapper;
    private final EnterpriseService enterpriseService; // Add this dependency

    @Async("taskExecutor")
    @Transactional
    public void processJob(
        String jobId,
        Function<String, Map<String, Object>> codeScanningFetcher,
        Function<String, Map<String, Object>> secretScanningFetcher,
        Function<String, Map<String, Object>> dependabotFetcher
    ) {
        log.info("ðŸš€ ASYNC JOB STARTED - Thread: {} - Job: {}", Thread.currentThread().getName(), jobId);
        log.info("Starting fully async processing for job: {}", jobId);

        Optional<EnterpriseJob> jobOpt = jobRepository.findById(jobId);
        if (jobOpt.isEmpty()) {
            log.error("Job {} not found for async processing.", jobId);
            return;
        }

        EnterpriseJob job = jobOpt.get();
        String githubToken = job.getGithubToken();

        try {
            updateJobStatus(job, EnterpriseJob.JobStatus.PROCESSING, 5, "Initializing enterprise scan...");

            updateJobStatus(job, null, 15, "Fetching code scanning alerts...");
            Map<String, Object> codeResults = codeScanningFetcher.apply(githubToken);
            @SuppressWarnings("unchecked")
            Map<String, Object> codeStats = (Map<String, Object>) codeResults.get("stats");
            log.info("Code scanning results: {}, Stats: {}", codeResults.get("count"), codeStats);
            updateJobStatus(job, null, 33, "Code scanning complete");

            updateJobStatus(job, null, 50, "Fetching secret scanning alerts...");
            Map<String, Object> secretResults = secretScanningFetcher.apply(githubToken);
            @SuppressWarnings("unchecked")
            Map<String, Object> secretStats = (Map<String, Object>) secretResults.get("stats");
            log.info("Secret scanning results: {}, Stats: {}", secretResults.get("count"), secretStats);
            updateJobStatus(job, null, 66, "Secret scanning complete");

            updateJobStatus(job, null, 80, "Fetching Dependabot alerts...");
            Map<String, Object> dependabotResults = dependabotFetcher.apply(githubToken);
            @SuppressWarnings("unchecked")
            Map<String, Object> dependabotStats = (Map<String, Object>) dependabotResults.get("stats");
            log.info("Dependabot results: {}, Stats: {}", dependabotResults.get("count"), dependabotStats);
            updateJobStatus(job, null, 90, "Dependabot scanning complete");

            // Process organization breakdown
            updateJobStatus(job, null, 95, "Processing organization breakdown...");
            
            // Extract alert lists from results
            @SuppressWarnings("unchecked")
            List<CodeScanningAlertDto> codeAlerts = (List<CodeScanningAlertDto>) codeResults.getOrDefault("alerts", new ArrayList<>());
            @SuppressWarnings("unchecked")
            List<SecretScanningAlertDto> secretAlerts = (List<SecretScanningAlertDto>) secretResults.getOrDefault("alerts", new ArrayList<>());
            @SuppressWarnings("unchecked")
            List<DependabotAlertDto> dependabotAlerts = (List<DependabotAlertDto>) dependabotResults.getOrDefault("alerts", new ArrayList<>());
            
            // Aggregate by organization
            Map<String, Object> organizationData = enterpriseService.aggregateByOrganization(codeAlerts, secretAlerts, dependabotAlerts);
            
            Map<String, Object> allResults = new HashMap<>();
            allResults.put("codeScanning", codeStats != null ? codeStats : new HashMap<>());
            allResults.put("secretScanning", secretStats != null ? secretStats : new HashMap<>());
            allResults.put("dependabot", dependabotStats != null ? dependabotStats : new HashMap<>());
            allResults.put("organizationBreakdown", organizationData.get("organizationBreakdown"));
            allResults.put("organizationSummary", Map.of(
                "totalOrganizations", organizationData.get("totalOrganizations"),
                "totalRepositories", organizationData.get("totalRepositories"),
                "totalAlerts", organizationData.get("totalAlerts")
            ));
            
            log.info("Final aggregated results with organization breakdown: enterprise stats + {} organizations", 
                    organizationData.get("totalOrganizations"));

            completeJob(job, allResults);

        } catch (Exception e) {
            log.error("Error during async processing for job {}: {}", job.getId(), e.getMessage(), e);
            failJob(job, "Processing failed: " + e.getMessage());
        }
    }

    private void updateJobStatus(EnterpriseJob job, EnterpriseJob.JobStatus status, Integer progress, String message) {
        if (status != null) job.setStatus(status);
        if (progress != null) job.setProgress(progress);
        EnterpriseJob updatedJob = jobRepository.save(job);
        webSocketService.sendJobProgressUpdate(job.getId(), convertToProgressUpdate(updatedJob, message, null));
    }

    private void completeJob(EnterpriseJob job, Map<String, Object> results) {
        try {
            String resultsJson = objectMapper.writeValueAsString(results);
            job.setPartialResults(resultsJson);
            job.setFinalResults(resultsJson);
            job.setStatus(EnterpriseJob.JobStatus.COMPLETED);
            job.setProgress(100);
            job.setCompletedAt(java.time.LocalDateTime.now());
            EnterpriseJob finalJob = jobRepository.save(job);
            webSocketService.sendJobProgressUpdate(job.getId(), convertToProgressUpdate(finalJob, "Scan completed successfully", results));
            log.info("Job {} completed successfully.", job.getId());
        } catch (Exception e) {
            log.error("Error serializing final results for job {}: {}", job.getId(), e.getMessage());
            failJob(job, "Failed to serialize results.");
        }
    }

    private void failJob(EnterpriseJob job, String errorMessage) {
        job.setStatus(EnterpriseJob.JobStatus.FAILED);
        job.setErrorMessage(errorMessage);
        job.setCompletedAt(java.time.LocalDateTime.now());
        EnterpriseJob failedJob = jobRepository.save(job);
        webSocketService.sendJobProgressUpdate(job.getId(), convertToProgressUpdate(failedJob, "Scan failed", null));
    }
    
    private JobProgressUpdateDto convertToProgressUpdate(EnterpriseJob job, String currentTask, Map<String, Object> results) {
        JobProgressUpdateDto.PartialResultsDto partialResults = null;
        if (results != null) {
            try {
                 partialResults = JobProgressUpdateDto.PartialResultsDto.builder()
                    .codeScanning(parseVulnerabilityStats((Map<String, Object>) results.get("codeScanning")))
                    .secretScanning(parseVulnerabilityStats((Map<String, Object>) results.get("secretScanning")))
                    .dependabot(parseVulnerabilityStats((Map<String, Object>) results.get("dependabot")))
                    .organizationBreakdown(results.get("organizationBreakdown"))
                    .organizationSummary(results.get("organizationSummary"))
                    .build();
            } catch (Exception e) {
                log.warn("Could not parse results for websocket update", e);
            }
        } else if (job.getPartialResults() != null && !job.getPartialResults().isEmpty()) {
             try {
                Map<String, Object> partialResultsMap = objectMapper.readValue(job.getPartialResults(), Map.class);
                partialResults = JobProgressUpdateDto.PartialResultsDto.builder()
                    .codeScanning(parseVulnerabilityStats((Map<String, Object>) partialResultsMap.get("codeScanning")))
                    .secretScanning(parseVulnerabilityStats((Map<String, Object>) partialResultsMap.get("secretScanning")))
                    .dependabot(parseVulnerabilityStats((Map<String, Object>) partialResultsMap.get("dependabot")))
                    .organizationBreakdown(partialResultsMap.get("organizationBreakdown"))
                    .organizationSummary(partialResultsMap.get("organizationSummary"))
                    .build();
            } catch (Exception e) {
                log.warn("Could not parse partial results for websocket update", e);
            }
        }

        return JobProgressUpdateDto.builder()
                .jobId(job.getId())
                .enterpriseName(job.getEnterpriseName())
                .status(JobProgressUpdateDto.JobStatus.valueOf(job.getStatus().name()))
                .progress(job.getProgress())
                .currentTask(currentTask)
                .partialResults(partialResults)
                .errorMessage(job.getErrorMessage())
                .createdAt(job.getCreatedAt())
                .build();
    }

    private JobProgressUpdateDto.VulnerabilityStatsDto parseVulnerabilityStats(Map<String, Object> stats) {
        if (stats == null) {
            return JobProgressUpdateDto.VulnerabilityStatsDto.builder()
                    .total(0).critical(0).high(0).medium(0).low(0).error(0)
                    .build();
        }
        
        return JobProgressUpdateDto.VulnerabilityStatsDto.builder()
                .total(getIntValue(stats, "total"))
                .critical(getIntValue(stats, "critical"))
                .high(getIntValue(stats, "high"))
                .medium(getIntValue(stats, "medium"))
                .low(getIntValue(stats, "low"))
                .error(getIntValue(stats, "error"))
                .build();
    }
    
    private int getIntValue(Map<String, Object> map, String key) {
        Object value = map.get(key);
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return 0;
    }
}
