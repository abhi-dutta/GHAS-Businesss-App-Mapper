package com.ghas.vulnerabilityinsights.service;

import com.ghas.vulnerabilityinsights.dto.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.List;

/**
 * Service for analyzing vulnerabilities across an organization.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class VulnerabilityAnalysisService {
    
    private final GitHubApiService gitHubApiService;
    
    /**
     * Get comprehensive vulnerability statistics for an organization.
     * This method processes ALL repositories in the organization to ensure accurate counts.
     */
    public Mono<OrganizationVulnerabilityStatsDto> getOrganizationVulnerabilityStats(String orgName, String token) {
        log.info("Starting comprehensive vulnerability analysis for organization: {}", orgName);
        
        return gitHubApiService.getOrganizationRepositories(orgName, token)
                .flatMapMany(repositories -> {
                    log.info("Found {} repositories in organization: {}", repositories.size(), orgName);
                    return Flux.fromIterable(repositories);
                })
                .flatMap(repo -> analyzeRepositoryVulnerabilities(orgName, repo.getName(), token)
                        .onErrorResume(error -> {
                            log.warn("Failed to analyze repository {}/{}: {}", orgName, repo.getName(), error.getMessage());
                            return Mono.just(new RepositoryVulnerabilityStats());
                        })
                        .timeout(Duration.ofSeconds(45)) // Increased timeout for more repositories
                        .delayElement(Duration.ofMillis(100)) // Small delay to respect rate limits
                , 10) // Process 10 repositories concurrently to balance speed and rate limits
                .reduce(new OrganizationVulnerabilityStatsDto(), this::aggregateStats)
                .doOnSuccess(stats -> {
                    stats.calculateTotalVulnerabilities();
                    log.info("Completed vulnerability analysis for organization: {}. Scanned {} repositories, Total vulnerabilities: {}", 
                            orgName, stats.getRepositoriesScanned(), stats.getTotalVulnerabilities());
                    log.info("Breakdown - SAST: {}, Secrets: {}, SCA: {}", 
                            stats.getSastVulnerabilities().getTotal(),
                            stats.getLeakedSecrets().getTotal(),
                            stats.getScaVulnerabilities().getTotal());
                });
    }
    
    /**
     * Get comprehensive vulnerability statistics for an organization using organization-level APIs.
     * This is more efficient than repository-by-repository analysis.
     */
    public Mono<OrganizationVulnerabilityStatsDto> getOrganizationVulnerabilityStatsEfficient(String orgName, String token) {
        log.info("Starting efficient vulnerability analysis for organization: {}", orgName);
        
        // Fetch all vulnerability data in parallel using organization-level endpoints
        Mono<List<CodeScanningAlertDto>> codeScanningAlerts = gitHubApiService.getOrganizationCodeScanningAlerts(orgName, token);
        Mono<List<DependabotAlertDto>> dependabotAlerts = gitHubApiService.getOrganizationDependabotAlerts(orgName, token);
        Mono<List<SecretScanningAlertDto>> secretScanningAlerts = gitHubApiService.getOrganizationSecretScanningAlerts(orgName, token);
        Mono<List<GitHubRepositoryDto>> repositories = gitHubApiService.getOrganizationRepositories(orgName, token);
        
        return Mono.zip(codeScanningAlerts, dependabotAlerts, secretScanningAlerts, repositories)
                .map(tuple -> {
                    OrganizationVulnerabilityStatsDto stats = new OrganizationVulnerabilityStatsDto();
                    
                    List<CodeScanningAlertDto> codeAlerts = tuple.getT1();
                    List<DependabotAlertDto> depAlerts = tuple.getT2();
                    List<SecretScanningAlertDto> secretAlerts = tuple.getT3();
                    List<GitHubRepositoryDto> repos = tuple.getT4();
                    
                    // Process code scanning alerts (SAST)
                    codeAlerts.stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                String severity = getSeverityFromCodeScanning(alert);
                                stats.getSastVulnerabilities().addVulnerability(severity);
                            });
                    
                    // Process dependabot alerts (SCA)
                    depAlerts.stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                String severity = getSeverityFromDependabot(alert);
                                stats.getScaVulnerabilities().addVulnerability(severity);
                            });
                    
                    // Process secret scanning alerts
                    secretAlerts.stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                // Secret scanning alerts are typically considered high severity
                                stats.getLeakedSecrets().addVulnerability("high");
                            });
                    
                    // Set the total number of repositories scanned
                    stats.setRepositoriesScanned(repos.size());
                    stats.calculateTotalVulnerabilities();
                    
                    log.info("Efficient analysis completed for organization: {}. Scanned {} repositories", orgName, repos.size());
                    log.info("Total vulnerabilities: {} (SAST: {}, Secrets: {}, SCA: {})", 
                            stats.getTotalVulnerabilities(),
                            stats.getSastVulnerabilities().getTotal(),
                            stats.getLeakedSecrets().getTotal(),
                            stats.getScaVulnerabilities().getTotal());
                    
                    return stats;
                })
                .onErrorResume(error -> {
                    log.error("Failed to get efficient vulnerability stats for organization {}: {}", orgName, error.getMessage());
                    // Fallback to repository-by-repository analysis
                    log.info("Falling back to repository-by-repository analysis for organization: {}", orgName);
                    return getOrganizationVulnerabilityStats(orgName, token);
                });
    }
    
    /**
     * Analyze vulnerabilities for a single repository.
     */
    private Mono<RepositoryVulnerabilityStats> analyzeRepositoryVulnerabilities(String orgName, String repoName, String token) {
        log.debug("Analyzing vulnerabilities for repository: {}/{}", orgName, repoName);
        
        Mono<List<CodeScanningAlertDto>> codeScanningAlerts = gitHubApiService.getCodeScanningAlerts(orgName, repoName, token);
        Mono<List<DependabotAlertDto>> dependabotAlerts = gitHubApiService.getDependabotAlerts(orgName, repoName, token);
        Mono<List<SecretScanningAlertDto>> secretScanningAlerts = gitHubApiService.getSecretScanningAlerts(orgName, repoName, token);
        
        return Mono.zip(codeScanningAlerts, dependabotAlerts, secretScanningAlerts)
                .map(tuple -> {
                    RepositoryVulnerabilityStats stats = new RepositoryVulnerabilityStats();
                    
                    // Process code scanning alerts (SAST)
                    tuple.getT1().stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                String severity = getSeverityFromCodeScanning(alert);
                                stats.sastVulnerabilities.addVulnerability(severity);
                            });
                    
                    // Process dependabot alerts (SCA)
                    tuple.getT2().stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                String severity = getSeverityFromDependabot(alert);
                                stats.scaVulnerabilities.addVulnerability(severity);
                            });
                    
                    // Process secret scanning alerts
                    tuple.getT3().stream()
                            .filter(alert -> "open".equals(alert.getState()))
                            .forEach(alert -> {
                                // Secret scanning alerts are typically considered high severity
                                stats.leakedSecrets.addVulnerability("high");
                            });
                    
                    log.debug("Repository {}/{} - SAST: {}, SCA: {}, Secrets: {}", 
                            orgName, repoName, 
                            stats.sastVulnerabilities.getTotal(),
                            stats.scaVulnerabilities.getTotal(),
                            stats.leakedSecrets.getTotal());
                    
                    return stats;
                });
    }
    
    /**
     * Extract severity from code scanning alert.
     */
    private String getSeverityFromCodeScanning(CodeScanningAlertDto alert) {
        if (alert.getRule() != null) {
            if (alert.getRule().getSecuritySeverityLevel() != null) {
                return alert.getRule().getSecuritySeverityLevel().toLowerCase();
            }
            if (alert.getRule().getSeverity() != null) {
                return alert.getRule().getSeverity().toLowerCase();
            }
        }
        return "medium"; // Default severity
    }
    
    /**
     * Extract severity from dependabot alert.
     */
    private String getSeverityFromDependabot(DependabotAlertDto alert) {
        if (alert.getSecurityAdvisory() != null && alert.getSecurityAdvisory().getSeverity() != null) {
            return alert.getSecurityAdvisory().getSeverity().toLowerCase();
        }
        if (alert.getSecurityVulnerability() != null && alert.getSecurityVulnerability().getSeverity() != null) {
            return alert.getSecurityVulnerability().getSeverity().toLowerCase();
        }
        return "medium"; // Default severity
    }
    
    /**
     * Aggregate repository statistics into organization statistics.
     */
    private OrganizationVulnerabilityStatsDto aggregateStats(OrganizationVulnerabilityStatsDto orgStats, RepositoryVulnerabilityStats repoStats) {
        // Aggregate SAST vulnerabilities
        orgStats.getSastVulnerabilities().setTotal(
                orgStats.getSastVulnerabilities().getTotal() + repoStats.sastVulnerabilities.getTotal());
        orgStats.getSastVulnerabilities().setCritical(
                orgStats.getSastVulnerabilities().getCritical() + repoStats.sastVulnerabilities.getCritical());
        orgStats.getSastVulnerabilities().setHigh(
                orgStats.getSastVulnerabilities().getHigh() + repoStats.sastVulnerabilities.getHigh());
        orgStats.getSastVulnerabilities().setMedium(
                orgStats.getSastVulnerabilities().getMedium() + repoStats.sastVulnerabilities.getMedium());
        orgStats.getSastVulnerabilities().setLow(
                orgStats.getSastVulnerabilities().getLow() + repoStats.sastVulnerabilities.getLow());
        
        // Aggregate SCA vulnerabilities
        orgStats.getScaVulnerabilities().setTotal(
                orgStats.getScaVulnerabilities().getTotal() + repoStats.scaVulnerabilities.getTotal());
        orgStats.getScaVulnerabilities().setCritical(
                orgStats.getScaVulnerabilities().getCritical() + repoStats.scaVulnerabilities.getCritical());
        orgStats.getScaVulnerabilities().setHigh(
                orgStats.getScaVulnerabilities().getHigh() + repoStats.scaVulnerabilities.getHigh());
        orgStats.getScaVulnerabilities().setMedium(
                orgStats.getScaVulnerabilities().getMedium() + repoStats.scaVulnerabilities.getMedium());
        orgStats.getScaVulnerabilities().setLow(
                orgStats.getScaVulnerabilities().getLow() + repoStats.scaVulnerabilities.getLow());
        
        // Aggregate leaked secrets
        orgStats.getLeakedSecrets().setTotal(
                orgStats.getLeakedSecrets().getTotal() + repoStats.leakedSecrets.getTotal());
        orgStats.getLeakedSecrets().setCritical(
                orgStats.getLeakedSecrets().getCritical() + repoStats.leakedSecrets.getCritical());
        orgStats.getLeakedSecrets().setHigh(
                orgStats.getLeakedSecrets().getHigh() + repoStats.leakedSecrets.getHigh());
        orgStats.getLeakedSecrets().setMedium(
                orgStats.getLeakedSecrets().getMedium() + repoStats.leakedSecrets.getMedium());
        orgStats.getLeakedSecrets().setLow(
                orgStats.getLeakedSecrets().getLow() + repoStats.leakedSecrets.getLow());
        
        // Increment repository count if any vulnerabilities were found or processed
        orgStats.setRepositoriesScanned(orgStats.getRepositoriesScanned() + 1);
        
        return orgStats;
    }
    
    /**
     * Internal class to hold vulnerability statistics for a single repository.
     */
    private static class RepositoryVulnerabilityStats {
        OrganizationVulnerabilityStatsDto.VulnerabilityCategory sastVulnerabilities;
        OrganizationVulnerabilityStatsDto.VulnerabilityCategory scaVulnerabilities;
        OrganizationVulnerabilityStatsDto.VulnerabilityCategory leakedSecrets;
        
        public RepositoryVulnerabilityStats() {
            this.sastVulnerabilities = new OrganizationVulnerabilityStatsDto.VulnerabilityCategory();
            this.scaVulnerabilities = new OrganizationVulnerabilityStatsDto.VulnerabilityCategory();
            this.leakedSecrets = new OrganizationVulnerabilityStatsDto.VulnerabilityCategory();
        }
    }
}