package com.ghas.vulnerabilityinsights.service;

import com.ghas.vulnerabilityinsights.dto.CodeScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.DependabotAlertDto;
import com.ghas.vulnerabilityinsights.dto.SecretScanningAlertDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Service for interacting with GitHub Enterprise APIs with improved pagination.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseService {

    private final WebClient webClient;

    @Value("${github.api.base-url:https://api.github.com}")
    private String githubApiBaseUrl;

    // Safety limits to prevent infinite loops
    private static final int MAX_PAGES = 100; // Max 100 pages = 10,000 alerts per type
    private static final int PAGE_SIZE = 100;

    /**
     * Get all code scanning alerts for an enterprise with pagination.
     */
    public Mono<List<CodeScanningAlertDto>> getEnterpriseCodeScanningAlerts(String enterprise, String token) {
        log.info("Fetching code scanning alerts for enterprise: {}", enterprise);
        return fetchAllCodeScanningAlerts(enterprise, token, 1, new ArrayList<>(), new HashSet<>());
    }

    /**
     * Get all secret scanning alerts for an enterprise with pagination.
     */
    public Mono<List<SecretScanningAlertDto>> getEnterpriseSecretScanningAlerts(String enterprise, String token) {
        log.info("Fetching secret scanning alerts for enterprise: {}", enterprise);
        String initialUrl = String.format("https://api.github.com/enterprises/%s/secret-scanning/alerts?per_page=%d&state=open", enterprise, PAGE_SIZE);
        return fetchAllSecretScanningAlerts(token, initialUrl, new ArrayList<>());
    }

    /**
     * Get all Dependabot alerts for an enterprise with pagination.
     */
    public Mono<List<DependabotAlertDto>> getEnterpriseDependabotAlerts(String enterprise, String token) {
        log.info("Fetching Dependabot alerts for enterprise: {}", enterprise);
        return fetchAllDependabotAlerts(enterprise, token, 1, new ArrayList<>(), new HashSet<>());
    }

    /**
     * Recursively fetch all code scanning alerts with improved pagination safety.
     */
    private Mono<List<CodeScanningAlertDto>> fetchAllCodeScanningAlerts(String enterprise, String token, int page, List<CodeScanningAlertDto> allAlerts, Set<String> seenAlertUrls) {
        if (page > MAX_PAGES) {
            log.warn("Reached maximum page limit ({}) for code scanning alerts for enterprise: {}, stopping pagination", MAX_PAGES, enterprise);
            return Mono.just(allAlerts);
        }
        
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                    .scheme("https")
                    .host("api.github.com")
                    .path("/enterprises/{enterprise}/code-scanning/alerts")
                    .queryParam("page", page)
                    .queryParam("per_page", PAGE_SIZE)
                    .queryParam("state", "open")
                    .build(enterprise))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<CodeScanningAlertDto>>() {})
                .flatMap(pageResults -> {
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more code scanning alerts found for enterprise {} at page {}, total: {}", enterprise, page, allAlerts.size());
                        return Mono.just(allAlerts);
                    }

                    List<CodeScanningAlertDto> newAlerts = pageResults.stream()
                        .filter(alert -> alert != null && alert.getHtmlUrl() != null && seenAlertUrls.add(alert.getHtmlUrl()))
                        .collect(Collectors.toList());

                    if (newAlerts.isEmpty() && !pageResults.isEmpty()) {
                        log.warn("No new (unique) code scanning alerts found on page {}. All alerts on this page were duplicates. Stopping pagination.", page);
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(newAlerts);
                    log.info("Fetched {} new code scanning alerts for enterprise {} (page {}), total so far: {}", newAlerts.size(), enterprise, page, allAlerts.size());
                    
                    if (pageResults.size() < PAGE_SIZE) {
                        log.info("Finished fetching code scanning alerts for enterprise {} (last page with {} alerts), total: {}", enterprise, pageResults.size(), allAlerts.size());
                        return Mono.just(allAlerts);
                    } else {
                        return fetchAllCodeScanningAlerts(enterprise, token, page + 1, allAlerts, seenAlertUrls);
                    }
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching code scanning alerts for enterprise {} (page {}): {} - {}", enterprise, page, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }

    /**
     * Recursively fetch all secret scanning alerts using cursor-based pagination with Link header.
     */
    private Mono<List<SecretScanningAlertDto>> fetchAllSecretScanningAlerts(String token, String apiUrl, List<SecretScanningAlertDto> allAlerts) {
        if (apiUrl == null || apiUrl.isEmpty()) {
            log.info("No more pages to fetch, total secret scanning alerts: {}", allAlerts.size());
            return Mono.just(allAlerts);
        }
        
        log.info("Fetching secret scanning alerts from URL: {}", apiUrl);

        return webClient.get()
                .uri(apiUrl)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .toEntity(new ParameterizedTypeReference<List<SecretScanningAlertDto>>() {})
                .flatMap(responseEntity -> {
                    List<SecretScanningAlertDto> pageResults = responseEntity.getBody();
                    
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more secret scanning alerts found, total: {}", allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(pageResults);
                    log.info("Fetched {} secret scanning alerts, total so far: {}", pageResults.size(), allAlerts.size());
                    
                    // Check Link header for next page URL
                    String linkHeader = responseEntity.getHeaders().getFirst("Link");
                    String nextUrl = null;
                    
                    if (linkHeader != null) {
                        String[] links = linkHeader.split(",");
                        for (String link : links) {
                            String[] parts = link.split(";");
                            if (parts.length > 1 && parts[1].contains("rel=\"next\"")) {
                                nextUrl = parts[0].trim();
                                // Remove angle brackets
                                nextUrl = nextUrl.substring(1, nextUrl.length() - 1);
                                break;
                            }
                        }
                    }
                    
                    if (nextUrl == null) {
                        log.info("No 'next' link found in Link header, finished fetching secret scanning alerts, total: {}", allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    return fetchAllSecretScanningAlerts(token, nextUrl, allAlerts);
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching secret scanning alerts from URL {}: {} - {}", apiUrl, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }
    
    /**
     * Recursively fetch all Dependabot alerts with improved pagination safety.
     */
    private Mono<List<DependabotAlertDto>> fetchAllDependabotAlerts(String enterprise, String token, int page, List<DependabotAlertDto> allAlerts, Set<String> seenAlertUrls) {
        if (page > MAX_PAGES) {
            log.warn("Reached maximum page limit ({}) for Dependabot alerts for enterprise: {}, stopping pagination", MAX_PAGES, enterprise);
            return Mono.just(allAlerts);
        }
        
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                    .scheme("https")
                    .host("api.github.com")
                    .path("/enterprises/{enterprise}/dependabot/alerts")
                    .queryParam("page", page)
                    .queryParam("per_page", PAGE_SIZE)
                    .queryParam("state", "open")
                    .build(enterprise))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<DependabotAlertDto>>() {})
                .flatMap(pageResults -> {
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more Dependabot alerts found for enterprise {} at page {}, total: {}", enterprise, page, allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    List<DependabotAlertDto> newAlerts = pageResults.stream()
                        .filter(alert -> alert != null && alert.getHtmlUrl() != null && seenAlertUrls.add(alert.getHtmlUrl()))
                        .collect(Collectors.toList());

                    if (newAlerts.isEmpty() && !pageResults.isEmpty()) {
                        log.warn("No new (unique) Dependabot alerts found on page {}. All alerts on this page were duplicates. Stopping pagination.", page);
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(newAlerts);
                    log.info("Fetched {} new Dependabot alerts for enterprise {} (page {}), total so far: {}", newAlerts.size(), enterprise, page, allAlerts.size());
                    
                    if (pageResults.size() < PAGE_SIZE) {
                        log.info("Finished fetching Dependabot alerts for enterprise {} (last page with {} alerts), total: {}", enterprise, pageResults.size(), allAlerts.size());
                        return Mono.just(allAlerts);
                    } else {
                        return fetchAllDependabotAlerts(enterprise, token, page + 1, allAlerts, seenAlertUrls);
                    }
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching Dependabot alerts for enterprise {} (page {}): {} - {}", enterprise, page, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }

    /**
     * Get consolidated enterprise vulnerability dashboard data.
     */
    public Mono<Map<String, Object>> getEnterpriseDashboardData(String enterprise, String token) {
        log.info("Fetching consolidated enterprise dashboard data for: {}", enterprise);
        
        return Mono.zip(
                getEnterpriseCodeScanningAlerts(enterprise, token),
                getEnterpriseSecretScanningAlerts(enterprise, token),
                getEnterpriseDependabotAlerts(enterprise, token)
        ).map(tuple -> {
            List<CodeScanningAlertDto> codeScanningAlerts = tuple.getT1();
            List<SecretScanningAlertDto> secretScanningAlerts = tuple.getT2();
            List<DependabotAlertDto> dependabotAlerts = tuple.getT3();
            
            // Calculate summary statistics
            Map<String, Object> summary = new HashMap<>();
            
            // Code scanning summary
            Map<String, Object> codeScanningStats = new HashMap<>();
            codeScanningStats.put("total", codeScanningAlerts.size());
            codeScanningStats.put("critical", codeScanningAlerts.stream()
                    .filter(alert -> alert.getRule() != null && "critical".equals(alert.getRule().getSecuritySeverityLevel()))
                    .count());
            codeScanningStats.put("high", codeScanningAlerts.stream()
                    .filter(alert -> alert.getRule() != null && "high".equals(alert.getRule().getSecuritySeverityLevel()))
                    .count());
            codeScanningStats.put("medium", codeScanningAlerts.stream()
                    .filter(alert -> alert.getRule() != null && "medium".equals(alert.getRule().getSecuritySeverityLevel()))
                    .count());
            codeScanningStats.put("low", codeScanningAlerts.stream()
                    .filter(alert -> alert.getRule() != null && "low".equals(alert.getRule().getSecuritySeverityLevel()))
                    .count());
            
            // Secret scanning summary
            Map<String, Object> secretScanningStats = new HashMap<>();
            secretScanningStats.put("total", secretScanningAlerts.size());
            Map<String, Long> byType = secretScanningAlerts.stream()
                    .collect(java.util.stream.Collectors.groupingBy(
                            alert -> alert.getSecretTypeDisplayName() != null ? 
                                    alert.getSecretTypeDisplayName() : "Unknown",
                            java.util.stream.Collectors.counting()));
            secretScanningStats.put("byType", byType);
            
            // Dependabot summary
            Map<String, Object> dependabotStats = new HashMap<>();
            dependabotStats.put("total", dependabotAlerts.size());
            dependabotStats.put("critical", dependabotAlerts.stream()
                    .filter(alert -> alert.getSecurityAdvisory() != null && "critical".equals(alert.getSecurityAdvisory().getSeverity()))
                    .count());
            dependabotStats.put("high", dependabotAlerts.stream()
                    .filter(alert -> alert.getSecurityAdvisory() != null && "high".equals(alert.getSecurityAdvisory().getSeverity()))
                    .count());
            dependabotStats.put("medium", dependabotAlerts.stream()
                    .filter(alert -> alert.getSecurityAdvisory() != null && "medium".equals(alert.getSecurityAdvisory().getSeverity()))
                    .count());
            dependabotStats.put("low", dependabotAlerts.stream()
                    .filter(alert -> alert.getSecurityAdvisory() != null && "low".equals(alert.getSecurityAdvisory().getSeverity()))
                    .count());
            
            summary.put("codeScanning", codeScanningStats);
            summary.put("secretScanning", secretScanningStats);
            summary.put("dependabot", dependabotStats);
            
            // Build response
            Map<String, Object> response = new HashMap<>();
            response.put("codeScanningAlerts", codeScanningAlerts);
            response.put("secretScanningAlerts", secretScanningAlerts);
            response.put("dependabotAlerts", dependabotAlerts);
            response.put("totalAlerts", codeScanningAlerts.size() + secretScanningAlerts.size() + dependabotAlerts.size());
            response.put("summary", summary);
            
            return response;
        });
    }
}