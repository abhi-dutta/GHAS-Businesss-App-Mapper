package com.ghas.vulnerabilityinsights.service;

import com.ghas.vulnerabilityinsights.dto.CodeScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.DependabotAlertDto;
import com.ghas.vulnerabilityinsights.dto.SecretScanningAlertDto;
import com.ghas.vulnerabilityinsights.dto.OrganizationRiskSummaryDto;
import com.ghas.vulnerabilityinsights.dto.GitHubRepositoryDto;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Service for interacting with GitHub Enterprise APIs with improved pagination.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseService {

    private final WebClient webClient;

    @Value("${github.api.base-url:https://api.github.com}")
    private String githubApiBaseUrl;

    // Safety limits to prevent infinite loops
    private static final int MAX_PAGES = 100; // Max 100 pages = 10,000 alerts per type
    private static final int PAGE_SIZE = 100;

    /**
     * Get all code scanning alerts for an enterprise with pagination.
     */
    public Mono<List<CodeScanningAlertDto>> getEnterpriseCodeScanningAlerts(String enterprise, String token) {
        log.info("Fetching code scanning alerts for enterprise: {}", enterprise);
        return fetchAllCodeScanningAlerts(enterprise, token, 1, new ArrayList<>(), new HashSet<>());
    }

    /**
     * Get all secret scanning alerts for an enterprise with pagination.
     */
    public Mono<List<SecretScanningAlertDto>> getEnterpriseSecretScanningAlerts(String enterprise, String token) {
        log.info("Fetching secret scanning alerts for enterprise: {}", enterprise);
        String initialUrl = String.format("https://api.github.com/enterprises/%s/secret-scanning/alerts?per_page=%d&state=open", enterprise, PAGE_SIZE);
        return fetchAllSecretScanningAlerts(token, initialUrl, new ArrayList<>());
    }

    /**
     * Get all Dependabot alerts for an enterprise with pagination.
     */
    public Mono<List<DependabotAlertDto>> getEnterpriseDependabotAlerts(String enterprise, String token) {
        log.info("Fetching Dependabot alerts for enterprise: {}", enterprise);
        return fetchAllDependabotAlerts(enterprise, token, 1, new ArrayList<>(), new HashSet<>());
    }

    /**
     * Recursively fetch all code scanning alerts with improved pagination safety.
     */
    private Mono<List<CodeScanningAlertDto>> fetchAllCodeScanningAlerts(String enterprise, String token, int page, List<CodeScanningAlertDto> allAlerts, Set<String> seenAlertUrls) {
        if (page > MAX_PAGES) {
            log.warn("Reached maximum page limit ({}) for code scanning alerts for enterprise: {}, stopping pagination", MAX_PAGES, enterprise);
            return Mono.just(allAlerts);
        }
        
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                    .scheme("https")
                    .host("api.github.com")
                    .path("/enterprises/{enterprise}/code-scanning/alerts")
                    .queryParam("page", page)
                    .queryParam("per_page", PAGE_SIZE)
                    .queryParam("state", "open")
                    .build(enterprise))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<CodeScanningAlertDto>>() {})
                .flatMap(pageResults -> {
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more code scanning alerts found for enterprise {} at page {}, total: {}", enterprise, page, allAlerts.size());
                        return Mono.just(allAlerts);
                    }

                    List<CodeScanningAlertDto> newAlerts = pageResults.stream()
                        .filter(alert -> alert != null && alert.getHtmlUrl() != null && seenAlertUrls.add(alert.getHtmlUrl()))
                        .collect(Collectors.toList());

                    if (newAlerts.isEmpty() && !pageResults.isEmpty()) {
                        log.warn("No new (unique) code scanning alerts found on page {}. All alerts on this page were duplicates. Stopping pagination.", page);
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(newAlerts);
                    log.info("Fetched {} new code scanning alerts for enterprise {} (page {}), total so far: {}", newAlerts.size(), enterprise, page, allAlerts.size());
                    
                    if (pageResults.size() < PAGE_SIZE) {
                        log.info("Finished fetching code scanning alerts for enterprise {} (last page with {} alerts), total: {}", enterprise, pageResults.size(), allAlerts.size());
                        return Mono.just(allAlerts);
                    } else {
                        return fetchAllCodeScanningAlerts(enterprise, token, page + 1, allAlerts, seenAlertUrls);
                    }
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching code scanning alerts for enterprise {} (page {}): {} - {}", enterprise, page, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }

    /**
     * Recursively fetch all secret scanning alerts using cursor-based pagination with Link header.
     */
    private Mono<List<SecretScanningAlertDto>> fetchAllSecretScanningAlerts(String token, String apiUrl, List<SecretScanningAlertDto> allAlerts) {
        if (apiUrl == null || apiUrl.isEmpty()) {
            log.info("No more pages to fetch, total secret scanning alerts: {}", allAlerts.size());
            return Mono.just(allAlerts);
        }
        
        log.info("Fetching secret scanning alerts from URL: {}", apiUrl);

        return webClient.get()
                .uri(apiUrl)
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .toEntity(new ParameterizedTypeReference<List<SecretScanningAlertDto>>() {})
                .flatMap(responseEntity -> {
                    List<SecretScanningAlertDto> pageResults = responseEntity.getBody();
                    
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more secret scanning alerts found, total: {}", allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(pageResults);
                    log.info("Fetched {} secret scanning alerts, total so far: {}", pageResults.size(), allAlerts.size());
                    
                    // Check Link header for next page URL
                    String linkHeader = responseEntity.getHeaders().getFirst("Link");
                    String nextUrl = null;
                    
                    if (linkHeader != null) {
                        String[] links = linkHeader.split(",");
                        for (String link : links) {
                            String[] parts = link.split(";");
                            if (parts.length > 1 && parts[1].contains("rel=\"next\"")) {
                                nextUrl = parts[0].trim();
                                // Remove angle brackets
                                nextUrl = nextUrl.substring(1, nextUrl.length() - 1);
                                break;
                            }
                        }
                    }
                    
                    if (nextUrl == null) {
                        log.info("No 'next' link found in Link header, finished fetching secret scanning alerts, total: {}", allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    return fetchAllSecretScanningAlerts(token, nextUrl, allAlerts);
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching secret scanning alerts from URL {}: {} - {}", apiUrl, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }
    
    /**
     * Recursively fetch all Dependabot alerts with improved pagination safety.
     */
    private Mono<List<DependabotAlertDto>> fetchAllDependabotAlerts(String enterprise, String token, int page, List<DependabotAlertDto> allAlerts, Set<String> seenAlertUrls) {
        if (page > MAX_PAGES) {
            log.warn("Reached maximum page limit ({}) for Dependabot alerts for enterprise: {}, stopping pagination", MAX_PAGES, enterprise);
            return Mono.just(allAlerts);
        }
        
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                    .scheme("https")
                    .host("api.github.com")
                    .path("/enterprises/{enterprise}/dependabot/alerts")
                    .queryParam("page", page)
                    .queryParam("per_page", PAGE_SIZE)
                    .queryParam("state", "open")
                    .build(enterprise))
                .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                .header(HttpHeaders.ACCEPT, "application/vnd.github+json")
                .header("X-GitHub-Api-Version", "2022-11-28")
                .header(HttpHeaders.USER_AGENT, "GHAS-Vulnerability-Insights")
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<List<DependabotAlertDto>>() {})
                .flatMap(pageResults -> {
                    if (pageResults == null || pageResults.isEmpty()) {
                        log.info("No more Dependabot alerts found for enterprise {} at page {}, total: {}", enterprise, page, allAlerts.size());
                        return Mono.just(allAlerts);
                    }
                    
                    List<DependabotAlertDto> newAlerts = pageResults.stream()
                        .filter(alert -> alert != null && alert.getHtmlUrl() != null && seenAlertUrls.add(alert.getHtmlUrl()))
                        .collect(Collectors.toList());

                    if (newAlerts.isEmpty() && !pageResults.isEmpty()) {
                        log.warn("No new (unique) Dependabot alerts found on page {}. All alerts on this page were duplicates. Stopping pagination.", page);
                        return Mono.just(allAlerts);
                    }
                    
                    allAlerts.addAll(newAlerts);
                    log.info("Fetched {} new Dependabot alerts for enterprise {} (page {}), total so far: {}", newAlerts.size(), enterprise, page, allAlerts.size());
                    
                    if (pageResults.size() < PAGE_SIZE) {
                        log.info("Finished fetching Dependabot alerts for enterprise {} (last page with {} alerts), total: {}", enterprise, pageResults.size(), allAlerts.size());
                        return Mono.just(allAlerts);
                    } else {
                        return fetchAllDependabotAlerts(enterprise, token, page + 1, allAlerts, seenAlertUrls);
                    }
                })
                .doOnError(WebClientResponseException.class, ex -> {
                    log.error("Error fetching Dependabot alerts for enterprise {} (page {}): {} - {}", enterprise, page, ex.getStatusCode(), ex.getResponseBodyAsString());
                })
                .onErrorReturn(allAlerts);
    }

    /**
     * Get consolidated enterprise vulnerability dashboard data.
     */
    public Mono<Map<String, Object>> getEnterpriseDashboardData(String enterprise, String token) {
        log.info("Fetching consolidated enterprise dashboard data for: {}", enterprise);
        
        return Mono.zip(
                getEnterpriseCodeScanningAlerts(enterprise, token),
                getEnterpriseSecretScanningAlerts(enterprise, token),
                getEnterpriseDependabotAlerts(enterprise, token)
        ).map(tuple -> {
            List<CodeScanningAlertDto> codeScanningAlerts = tuple.getT1();
            List<SecretScanningAlertDto> secretScanningAlerts = tuple.getT2();
            List<DependabotAlertDto> dependabotAlerts = tuple.getT3();
            
            log.info("Processing {} code scanning, {} secret scanning, {} dependabot alerts", 
                    codeScanningAlerts.size(), secretScanningAlerts.size(), dependabotAlerts.size());
            
            // Calculate summary statistics with enhanced categorization
            Map<String, Object> summary = new HashMap<>();
            
            // Code scanning summary with robust severity mapping
            Map<String, Object> codeScanningStats = categorizeCodeScanningAlerts(codeScanningAlerts);
            
            // Secret scanning summary (all treated as high severity)
            Map<String, Object> secretScanningStats = categorizeSecretScanningAlerts(secretScanningAlerts);
            
            // Dependabot summary with comprehensive severity mapping
            Map<String, Object> dependabotStats = categorizeDependabotAlerts(dependabotAlerts);
            
            summary.put("codeScanning", codeScanningStats);
            summary.put("secretScanning", secretScanningStats);
            summary.put("dependabot", dependabotStats);
            
            // Build response
            Map<String, Object> response = new HashMap<>();
            response.put("codeScanningAlerts", codeScanningAlerts);
            response.put("secretScanningAlerts", secretScanningAlerts);
            response.put("dependabotAlerts", dependabotAlerts);
            response.put("totalAlerts", codeScanningAlerts.size() + secretScanningAlerts.size() + dependabotAlerts.size());
            response.put("summary", summary);
            
            log.info("Enterprise dashboard data processing completed for: {}", enterprise);
            return response;
        });
    }
    
    /**
     * Categorize code scanning alerts by severity level.
     * Maps both severity and securitySeverityLevel fields to standardized categories.
     */
    private Map<String, Object> categorizeCodeScanningAlerts(List<CodeScanningAlertDto> alerts) {
        Map<String, Object> stats = new HashMap<>();
        
        long critical = alerts.stream().filter(alert -> 
            isCriticalSeverity(getCodeScanningSeverity(alert))).count();
        
        long high = alerts.stream().filter(alert -> 
            isHighSeverity(getCodeScanningSeverity(alert))).count();
        
        long medium = alerts.stream().filter(alert -> 
            isMediumSeverity(getCodeScanningSeverity(alert))).count();
        
        long low = alerts.stream().filter(alert -> 
            isLowSeverity(getCodeScanningSeverity(alert))).count();
        
        long error = alerts.stream().filter(alert -> 
            isErrorSeverity(getCodeScanningSeverity(alert))).count();
        
        stats.put("total", alerts.size());
        stats.put("critical", critical);
        stats.put("high", high);
        stats.put("medium", medium);
        stats.put("low", low);
        stats.put("error", error);
        
        log.debug("Code scanning categorization: total={}, critical={}, high={}, medium={}, low={}, error={}", 
                alerts.size(), critical, high, medium, low, error);
        
        return stats;
    }
    
    /**
     * Categorize secret scanning alerts.
     * All secret scanning alerts are considered HIGH severity by default.
     */
    private Map<String, Object> categorizeSecretScanningAlerts(List<SecretScanningAlertDto> alerts) {
        Map<String, Object> stats = new HashMap<>();
        
        // All secret scanning alerts are considered high severity
        stats.put("total", alerts.size());
        stats.put("critical", 0L);
        stats.put("high", (long) alerts.size());
        stats.put("medium", 0L);
        stats.put("low", 0L);
        stats.put("error", 0L);
        
        // Group by secret type for additional insights
        Map<String, Long> byType = alerts.stream()
                .collect(java.util.stream.Collectors.groupingBy(
                        alert -> alert.getSecretTypeDisplayName() != null ? 
                                alert.getSecretTypeDisplayName() : "Unknown",
                        java.util.stream.Collectors.counting()));
        stats.put("byType", byType);
        
        log.debug("Secret scanning categorization: total={} (all high severity), types={}", 
                alerts.size(), byType.size());
        
        return stats;
    }
    
    /**
     * Categorize Dependabot alerts by severity level.
     * Maps both securityAdvisory and securityVulnerability severity fields.
     */
    private Map<String, Object> categorizeDependabotAlerts(List<DependabotAlertDto> alerts) {
        Map<String, Object> stats = new HashMap<>();
        
        long critical = alerts.stream().filter(alert -> 
            isCriticalSeverity(getDependabotSeverity(alert))).count();
        
        long high = alerts.stream().filter(alert -> 
            isHighSeverity(getDependabotSeverity(alert))).count();
        
        long medium = alerts.stream().filter(alert -> 
            isMediumSeverity(getDependabotSeverity(alert))).count();
        
        long low = alerts.stream().filter(alert -> 
            isLowSeverity(getDependabotSeverity(alert))).count();
        
        long error = alerts.stream().filter(alert -> 
            isErrorSeverity(getDependabotSeverity(alert))).count();
        
        stats.put("total", alerts.size());
        stats.put("critical", critical);
        stats.put("high", high);
        stats.put("medium", medium);
        stats.put("low", low);
        stats.put("error", error);
        
        log.debug("Dependabot categorization: total={}, critical={}, high={}, medium={}, low={}, error={}", 
                alerts.size(), critical, high, medium, low, error);
        
        return stats;
    }
    
    /**
     * Extract severity level from code scanning alert.
     * Prioritizes securitySeverityLevel over severity field.
     */
    private String getCodeScanningSeverity(CodeScanningAlertDto alert) {
        if (alert.getRule() == null) {
            return "unknown";
        }
        
        // Prioritize security severity level
        if (alert.getRule().getSecuritySeverityLevel() != null) {
            return alert.getRule().getSecuritySeverityLevel().toLowerCase().trim();
        }
        
        // Fallback to general severity
        if (alert.getRule().getSeverity() != null) {
            return alert.getRule().getSeverity().toLowerCase().trim();
        }
        
        return "unknown";
    }
    
    /**
     * Extract severity level from Dependabot alert.
     * Prioritizes securityAdvisory severity over securityVulnerability severity.
     */
    private String getDependabotSeverity(DependabotAlertDto alert) {
        // Prioritize security advisory severity
        if (alert.getSecurityAdvisory() != null && alert.getSecurityAdvisory().getSeverity() != null) {
            return alert.getSecurityAdvisory().getSeverity().toLowerCase().trim();
        }
        
        // Fallback to security vulnerability severity
        if (alert.getSecurityVulnerability() != null && alert.getSecurityVulnerability().getSeverity() != null) {
            return alert.getSecurityVulnerability().getSeverity().toLowerCase().trim();
        }
        
        return "unknown";
    }
    
    /**
     * Determine if severity level is CRITICAL.
     */
    private boolean isCriticalSeverity(String severity) {
        return "critical".equals(severity);
    }
    
    /**
     * Determine if severity level is HIGH.
     */
    private boolean isHighSeverity(String severity) {
        return "high".equals(severity);
    }
    
    /**
     * Determine if severity level is MEDIUM.
     */
    private boolean isMediumSeverity(String severity) {
        return "medium".equals(severity) || "moderate".equals(severity);
    }
    
    /**
     * Determine if severity level is LOW.
     */
    private boolean isLowSeverity(String severity) {
        return "low".equals(severity) || "info".equals(severity) || "informational".equals(severity);
    }
    
    /**
     * Determine if severity level is ERROR/UNKNOWN.
     */
    private boolean isErrorSeverity(String severity) {
        return "unknown".equals(severity) || "error".equals(severity) || severity == null || severity.isEmpty();
    }

    // ===== INTERNAL METHODS FOR ASYNC JOB PROCESSING =====
    
    /**
     * Internal method to get code scanning alerts (synchronous for async job processing)
     */
    public Map<String, Object> getCodeScanningAlertsInternal(String enterprise, String token) {
        try {
            log.info("Internal: Fetching code scanning alerts for enterprise: {}", enterprise);
            
            List<CodeScanningAlertDto> alerts = getEnterpriseCodeScanningAlerts(enterprise, token).block();
            log.info("Fetched {} code scanning alerts for enterprise: {}", 
                    alerts != null ? alerts.size() : 0, enterprise);
            
            Map<String, Object> stats = categorizeCodeScanningAlerts(alerts != null ? alerts : new ArrayList<>());
            log.info("Code scanning stats for enterprise {}: {}", enterprise, stats);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", alerts);
            result.put("stats", stats);
            result.put("count", alerts != null ? alerts.size() : 0);
            
            return result;
            
        } catch (Exception e) {
            log.error("Internal error fetching code scanning alerts for enterprise {}: {}", enterprise, e.getMessage(), e);
            
            // Return empty stats instead of throwing exception
            Map<String, Object> emptyStats = new HashMap<>();
            emptyStats.put("total", 0);
            emptyStats.put("critical", 0);
            emptyStats.put("high", 0);
            emptyStats.put("medium", 0);
            emptyStats.put("low", 0);
            emptyStats.put("error", 0);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", new ArrayList<>());
            result.put("stats", emptyStats);
            result.put("count", 0);
            result.put("errorMessage", e.getMessage());
            
            return result;
        }
    }
    
    /**
     * Internal method to get secret scanning alerts (synchronous for async job processing)
     */
    public Map<String, Object> getSecretScanningAlertsInternal(String enterprise, String token) {
        try {
            log.info("Internal: Fetching secret scanning alerts for enterprise: {}", enterprise);
            
            List<SecretScanningAlertDto> alerts = getEnterpriseSecretScanningAlerts(enterprise, token).block();
            log.info("Fetched {} secret scanning alerts for enterprise: {}", 
                    alerts != null ? alerts.size() : 0, enterprise);
            
            Map<String, Object> stats = categorizeSecretScanningAlerts(alerts != null ? alerts : new ArrayList<>());
            log.info("Secret scanning stats for enterprise {}: {}", enterprise, stats);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", alerts);
            result.put("stats", stats);
            result.put("count", alerts != null ? alerts.size() : 0);
            
            return result;
            
        } catch (Exception e) {
            log.error("Internal error fetching secret scanning alerts for enterprise {}: {}", enterprise, e.getMessage(), e);
            
            // Return empty stats instead of throwing exception
            Map<String, Object> emptyStats = new HashMap<>();
            emptyStats.put("total", 0);
            emptyStats.put("critical", 0);
            emptyStats.put("high", 0);
            emptyStats.put("medium", 0);
            emptyStats.put("low", 0);
            emptyStats.put("error", 0);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", new ArrayList<>());
            result.put("stats", emptyStats);
            result.put("count", 0);
            result.put("errorMessage", e.getMessage());
            
            return result;
        }
    }
    
    /**
     * Internal method to get Dependabot alerts (synchronous for async job processing)
     */
    public Map<String, Object> getDependabotAlertsInternal(String enterprise, String token) {
        try {
            log.info("Internal: Fetching Dependabot alerts for enterprise: {}", enterprise);
            
            List<DependabotAlertDto> alerts = getEnterpriseDependabotAlerts(enterprise, token).block();
            log.info("Fetched {} Dependabot alerts for enterprise: {}", 
                    alerts != null ? alerts.size() : 0, enterprise);
            
            Map<String, Object> stats = categorizeDependabotAlerts(alerts != null ? alerts : new ArrayList<>());
            log.info("Dependabot stats for enterprise {}: {}", enterprise, stats);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", alerts);
            result.put("stats", stats);
            result.put("count", alerts != null ? alerts.size() : 0);
            
            return result;
            
        } catch (Exception e) {
            log.error("Internal error fetching Dependabot alerts for enterprise {}: {}", enterprise, e.getMessage(), e);
            
            // Return empty stats instead of throwing exception
            Map<String, Object> emptyStats = new HashMap<>();
            emptyStats.put("total", 0);
            emptyStats.put("critical", 0);
            emptyStats.put("high", 0);
            emptyStats.put("medium", 0);
            emptyStats.put("low", 0);
            emptyStats.put("error", 0);
            
            Map<String, Object> result = new HashMap<>();
            result.put("alerts", new ArrayList<>());
            result.put("stats", emptyStats);
            result.put("count", 0);
            result.put("errorMessage", e.getMessage());
            
            return result;
        }
    }
    
    /**
     * Internal method to build dashboard response (synchronous for async job processing)
     */
    public Map<String, Object> buildDashboardResponseInternal(String enterprise, String token) {
        try {
            log.info("Internal: Building dashboard response for enterprise: {}", enterprise);
            
            Map<String, Object> dashboardData = getEnterpriseDashboardData(enterprise, token).block();
            return dashboardData != null ? dashboardData : new HashMap<>();
            
        } catch (Exception e) {
            log.error("Internal error building dashboard response: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to build dashboard response: " + e.getMessage(), e);
        }
    }

    // ===== ORGANIZATION-LEVEL DATA PROCESSING =====
    
    /**
     * Extract organization name from repository URL.
     * GitHub repository URLs follow the pattern: https://api.github.com/repos/{org}/{repo}
     * or https://github.com/{org}/{repo}
     */
    /**
     * Extract organization name from repository DTO using the owner.login field.
     */
    private String extractOrganizationFromRepository(Object repositoryObj) {
        if (repositoryObj == null) {
            log.debug("Repository object is null, returning 'unknown'");
            return "unknown";
        }
        
        try {
            String organizationName = null;
            
            // Handle GitHubRepositoryDto object
            if (repositoryObj instanceof GitHubRepositoryDto) {
                GitHubRepositoryDto repo = (GitHubRepositoryDto) repositoryObj;
                if (repo.getOwner() != null && repo.getOwner().getLogin() != null) {
                    organizationName = repo.getOwner().getLogin();
                    log.debug("Extracted organization '{}' from GitHubRepositoryDto.owner.login", organizationName);
                } else {
                    log.debug("GitHubRepositoryDto missing owner.login, checking full_name: '{}'", repo.getFullName());
                    // Fallback to full_name parsing
                    if (repo.getFullName() != null && repo.getFullName().contains("/")) {
                        String[] parts = repo.getFullName().split("/");
                        if (parts.length >= 2) {
                            organizationName = parts[0];
                            log.debug("Extracted organization '{}' from full_name fallback", organizationName);
                        }
                    }
                }
            }
            // Handle Map representation (JSON deserialization)
            else if (repositoryObj instanceof Map) {
                Map<?, ?> repoMap = (Map<?, ?>) repositoryObj;
                
                // First try to get from owner.login
                Object ownerObj = repoMap.get("owner");
                if (ownerObj instanceof Map) {
                    Map<?, ?> ownerMap = (Map<?, ?>) ownerObj;
                    Object loginObj = ownerMap.get("login");
                    if (loginObj instanceof String) {
                        organizationName = (String) loginObj;
                        log.debug("Extracted organization '{}' from Map.owner.login", organizationName);
                    }
                }
                
                // Fallback to full_name parsing if owner.login not available
                if (organizationName == null) {
                    Object fullNameObj = repoMap.get("full_name");
                    if (fullNameObj instanceof String) {
                        String fullName = (String) fullNameObj;
                        if (fullName.contains("/")) {
                            String[] parts = fullName.split("/");
                            if (parts.length >= 2) {
                                organizationName = parts[0];
                                log.debug("Extracted organization '{}' from Map.full_name fallback", organizationName);
                            }
                        }
                    }
                }
            }
            // Handle String representation
            else if (repositoryObj instanceof String) {
                String repositoryUrl = (String) repositoryObj;
                log.debug("Repository object is String: '{}'", repositoryUrl);
                
                // Try to extract from full_name format (org/repo)
                if (repositoryUrl.contains("/") && !repositoryUrl.startsWith("http")) {
                    String[] parts = repositoryUrl.split("/");
                    if (parts.length >= 2) {
                        organizationName = parts[0];
                        log.debug("Extracted organization '{}' from String full_name format", organizationName);
                    }
                }
                // Handle URL format
                else if (repositoryUrl.startsWith("http")) {
                    String[] urlParts = repositoryUrl.split("/");
                    for (int i = 0; i < urlParts.length - 1; i++) {
                        if ("repos".equals(urlParts[i]) && i + 1 < urlParts.length) {
                            organizationName = urlParts[i + 1];
                            log.debug("Extracted organization '{}' from API URL format", organizationName);
                            break;
                        }
                    }
                    // Fallback for github.com URLs
                    if (organizationName == null && urlParts.length >= 4 && urlParts[2].contains("github")) {
                        organizationName = urlParts[3];
                        log.debug("Extracted organization '{}' from GitHub URL format", organizationName);
                    }
                }
            } else {
                log.debug("Repository object type not recognized: {}", repositoryObj.getClass());
            }
            
            if (organizationName != null && !organizationName.trim().isEmpty()) {
                return organizationName.trim();
            }
            
        } catch (Exception e) {
            log.warn("Error extracting organization from repository: {}", repositoryObj, e);
        }
        
        log.debug("Could not extract organization from '{}', returning 'unknown'", repositoryObj);
        return "unknown";
    }
    
    /**
     * Aggregate alerts by organization and calculate risk summaries.
     */
    public Map<String, Object> aggregateByOrganization(
            List<CodeScanningAlertDto> codeAlerts,
            List<SecretScanningAlertDto> secretAlerts,
            List<DependabotAlertDto> dependabotAlerts) {
        
        log.info("Aggregating alerts by organization: {} code, {} secret, {} dependabot", 
                codeAlerts.size(), secretAlerts.size(), dependabotAlerts.size());
        
        Map<String, OrganizationAggregator> orgAggregators = new HashMap<>();
        
        // Process code scanning alerts
        for (CodeScanningAlertDto alert : codeAlerts) {
            String org = extractOrganizationFromRepository(alert.getRepository());
            log.debug("Code scanning alert from repository: {} -> org: '{}'", 
                     getRepositoryIdentifier(alert.getRepository()), org);
            orgAggregators.computeIfAbsent(org, k -> new OrganizationAggregator(k))
                    .addCodeScanningAlert(alert);
        }
        
        // Process secret scanning alerts
        for (SecretScanningAlertDto alert : secretAlerts) {
            String org = extractOrganizationFromRepository(alert.getRepository());
            log.debug("Secret scanning alert from repository: {} -> org: '{}'", 
                     getRepositoryIdentifier(alert.getRepository()), org);
            orgAggregators.computeIfAbsent(org, k -> new OrganizationAggregator(k))
                    .addSecretScanningAlert(alert);
        }
        
        // Process Dependabot alerts
        for (DependabotAlertDto alert : dependabotAlerts) {
            String org = extractOrganizationFromRepository(alert.getRepository());
            log.debug("Dependabot alert from repository: {} -> org: '{}'", 
                     getRepositoryIdentifier(alert.getRepository()), org);
            orgAggregators.computeIfAbsent(org, k -> new OrganizationAggregator(k))
                    .addDependabotAlert(alert);
        }
        
        log.info("Found {} unique organizations: {}", orgAggregators.size(), orgAggregators.keySet());
        
        // Log details for each organization
        for (Map.Entry<String, OrganizationAggregator> entry : orgAggregators.entrySet()) {
            OrganizationAggregator aggregator = entry.getValue();
            log.info("Organization '{}': {} repositories, {} total alerts (code: {}, secret: {}, dependabot: {})", 
                    entry.getKey(), 
                    aggregator.getRepositoryCount(),
                    aggregator.getTotalAlerts(),
                    aggregator.getCodeAlerts().size(),
                    aggregator.getSecretAlerts().size(),
                    aggregator.getDependabotAlerts().size());
        }
        
        // Convert to organization risk summaries
        List<OrganizationRiskSummaryDto> organizationSummaries = orgAggregators.values().stream()
                .map(this::buildOrganizationRiskSummary)
                .sorted((a, b) -> Double.compare(b.getRiskScore(), a.getRiskScore())) // Sort by risk score descending
                .collect(Collectors.toList());
        
        // Calculate totals
        int totalOrganizations = organizationSummaries.size();
        int totalRepositories = organizationSummaries.stream()
                .mapToInt(org -> org.getTotalRepositories() != null ? org.getTotalRepositories() : 0)
                .sum();
        int totalAlerts = organizationSummaries.stream()
                .mapToInt(org -> org.getTotalAlerts() != null ? org.getTotalAlerts() : 0)
                .sum();
        
        Map<String, Object> result = new HashMap<>();
        result.put("organizationBreakdown", organizationSummaries);
        result.put("totalOrganizations", totalOrganizations);
        result.put("totalRepositories", totalRepositories);
        result.put("totalAlerts", totalAlerts);
        
        log.info("Organization aggregation complete: {} organizations, {} repositories, {} total alerts", 
                totalOrganizations, totalRepositories, totalAlerts);
        
        return result;
    }
    
    /**
     * Build organization risk summary from aggregator.
     */
    private OrganizationRiskSummaryDto buildOrganizationRiskSummary(OrganizationAggregator aggregator) {
        return OrganizationRiskSummaryDto.builder()
                .organizationName(aggregator.getOrganizationName())
                .codeScanning(aggregator.getCodeScanningStats())
                .secretScanning(aggregator.getSecretScanningStats())
                .dependabot(aggregator.getDependabotStats())
                .totalRepositories(aggregator.getRepositoryCount())
                .totalAlerts(aggregator.getTotalAlerts())
                .riskScore(aggregator.calculateRiskScore())
                .lastUpdated(java.time.LocalDateTime.now())
                .build();
    }
    
    /**
     * Helper class to aggregate alerts by organization.
     */
    private static class OrganizationAggregator {
        private final String organizationName;
        private final Set<String> repositories = new HashSet<>();
        private final List<CodeScanningAlertDto> codeAlerts = new ArrayList<>();
        private final List<SecretScanningAlertDto> secretAlerts = new ArrayList<>();
        private final List<DependabotAlertDto> dependabotAlerts = new ArrayList<>();
        
        public OrganizationAggregator(String organizationName) {
            this.organizationName = organizationName;
        }
        
        public void addCodeScanningAlert(CodeScanningAlertDto alert) {
            codeAlerts.add(alert);
            addRepository(alert.getRepository());
        }
        
        public void addSecretScanningAlert(SecretScanningAlertDto alert) {
            secretAlerts.add(alert);
            addRepository(alert.getRepository());
        }
        
        public void addDependabotAlert(DependabotAlertDto alert) {
            dependabotAlerts.add(alert);
            addRepository(alert.getRepository());
        }
        
        private void addRepository(Object repositoryObj) {
            String repositoryKey = null;
            
            if (repositoryObj instanceof GitHubRepositoryDto) {
                GitHubRepositoryDto repo = (GitHubRepositoryDto) repositoryObj;
                repositoryKey = repo.getFullName() != null ? repo.getFullName() : 
                              (repo.getName() != null ? repo.getName() : String.valueOf(repo.getId()));
            } else if (repositoryObj instanceof Map) {
                Map<?, ?> repoMap = (Map<?, ?>) repositoryObj;
                repositoryKey = (String) repoMap.get("full_name");
                if (repositoryKey == null) {
                    repositoryKey = (String) repoMap.get("name");
                }
                if (repositoryKey == null) {
                    Object id = repoMap.get("id");
                    if (id != null) {
                        repositoryKey = String.valueOf(id);
                    }
                }
            } else if (repositoryObj instanceof String) {
                repositoryKey = (String) repositoryObj;
            }
            
            if (repositoryKey != null && !repositoryKey.trim().isEmpty()) {
                repositories.add(repositoryKey.trim());
            }
        }
        
        public String getOrganizationName() {
            return organizationName;
        }
        
        public int getRepositoryCount() {
            return repositories.size();
        }
        
        public int getTotalAlerts() {
            return codeAlerts.size() + secretAlerts.size() + dependabotAlerts.size();
        }
        
        public OrganizationRiskSummaryDto.VulnerabilityStatsDto getCodeScanningStats() {
            return buildStatsFromCodeAlerts(codeAlerts);
        }
        
        public OrganizationRiskSummaryDto.VulnerabilityStatsDto getSecretScanningStats() {
            return OrganizationRiskSummaryDto.VulnerabilityStatsDto.builder()
                    .total(secretAlerts.size())
                    .critical(0)
                    .high(secretAlerts.size()) // All secrets are high severity
                    .medium(0)
                    .low(0)
                    .error(0)
                    .unknown(0)
                    .build();
        }
        
        public OrganizationRiskSummaryDto.VulnerabilityStatsDto getDependabotStats() {
            return buildStatsFromDependabotAlerts(dependabotAlerts);
        }
        
        public double calculateRiskScore() {
            // Simple risk scoring algorithm based on severity distribution
            int critical = 0, high = 0, medium = 0, low = 0;
            
            // Code scanning
            OrganizationRiskSummaryDto.VulnerabilityStatsDto codeStats = getCodeScanningStats();
            critical += codeStats.getCritical();
            high += codeStats.getHigh();
            medium += codeStats.getMedium();
            low += codeStats.getLow();
            
            // Secret scanning (all high)
            high += secretAlerts.size();
            
            // Dependabot
            OrganizationRiskSummaryDto.VulnerabilityStatsDto dependabotStats = getDependabotStats();
            critical += dependabotStats.getCritical();
            high += dependabotStats.getHigh();
            medium += dependabotStats.getMedium();
            low += dependabotStats.getLow();
            
            // Calculate weighted risk score (max 100)
            double score = (critical * 10.0) + (high * 5.0) + (medium * 2.0) + (low * 1.0);
            return Math.min(100.0, score); // Cap at 100
        }
        
        private OrganizationRiskSummaryDto.VulnerabilityStatsDto buildStatsFromCodeAlerts(List<CodeScanningAlertDto> alerts) {
            int critical = 0, high = 0, medium = 0, low = 0, error = 0;
            
            for (CodeScanningAlertDto alert : alerts) {
                String severity = getCodeScanningSeverity(alert);
                switch (severity) {
                    case "critical": critical++; break;
                    case "high": high++; break;
                    case "medium": case "moderate": medium++; break;
                    case "low": case "info": case "informational": low++; break;
                    default: error++; break;
                }
            }
            
            return OrganizationRiskSummaryDto.VulnerabilityStatsDto.builder()
                    .total(alerts.size())
                    .critical(critical)
                    .high(high)
                    .medium(medium)
                    .low(low)
                    .error(error)
                    .unknown(0)
                    .build();
        }
        
        private OrganizationRiskSummaryDto.VulnerabilityStatsDto buildStatsFromDependabotAlerts(List<DependabotAlertDto> alerts) {
            int critical = 0, high = 0, medium = 0, low = 0, error = 0;
            
            for (DependabotAlertDto alert : alerts) {
                String severity = getDependabotSeverity(alert);
                switch (severity) {
                    case "critical": critical++; break;
                    case "high": high++; break;
                    case "medium": case "moderate": medium++; break;
                    case "low": case "info": case "informational": low++; break;
                    default: error++; break;
                }
            }
            
            return OrganizationRiskSummaryDto.VulnerabilityStatsDto.builder()
                    .total(alerts.size())
                    .critical(critical)
                    .high(high)
                    .medium(medium)
                    .low(low)
                    .error(error)
                    .unknown(0)
                    .build();
        }
        
        private String getCodeScanningSeverity(CodeScanningAlertDto alert) {
            if (alert.getRule() == null) return "unknown";
            if (alert.getRule().getSecuritySeverityLevel() != null) {
                return alert.getRule().getSecuritySeverityLevel().toLowerCase().trim();
            }
            if (alert.getRule().getSeverity() != null) {
                return alert.getRule().getSeverity().toLowerCase().trim();
            }
            return "unknown";
        }
        
        private String getDependabotSeverity(DependabotAlertDto alert) {
            if (alert.getSecurityAdvisory() != null && alert.getSecurityAdvisory().getSeverity() != null) {
                return alert.getSecurityAdvisory().getSeverity().toLowerCase().trim();
            }
            if (alert.getSecurityVulnerability() != null && alert.getSecurityVulnerability().getSeverity() != null) {
                return alert.getSecurityVulnerability().getSeverity().toLowerCase().trim();
            }
            return "unknown";
        }

        public List<CodeScanningAlertDto> getCodeAlerts() {
            return codeAlerts;
        }
        
        public List<SecretScanningAlertDto> getSecretAlerts() {
            return secretAlerts;
        }
        
        public List<DependabotAlertDto> getDependabotAlerts() {
            return dependabotAlerts;
        }
    }

    /**
     * Helper method to get a readable repository identifier for logging.
     */
    private String getRepositoryIdentifier(Object repositoryObj) {
        if (repositoryObj instanceof GitHubRepositoryDto) {
            GitHubRepositoryDto repo = (GitHubRepositoryDto) repositoryObj;
            return repo.getFullName() != null ? repo.getFullName() : repo.getName();
        } else if (repositoryObj instanceof Map) {
            Map<?, ?> repoMap = (Map<?, ?>) repositoryObj;
            String fullName = (String) repoMap.get("full_name");
            return fullName != null ? fullName : (String) repoMap.get("name");
        } else if (repositoryObj instanceof String) {
            return (String) repositoryObj;
        }
        return String.valueOf(repositoryObj);
    }
}