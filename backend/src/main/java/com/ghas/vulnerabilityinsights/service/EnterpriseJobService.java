package com.ghas.vulnerabilityinsights.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ghas.vulnerabilityinsights.dto.JobProgressUpdateDto;
import com.ghas.vulnerabilityinsights.dto.JobStartResponseDto;
import com.ghas.vulnerabilityinsights.model.EnterpriseJob;
import com.ghas.vulnerabilityinsights.repository.EnterpriseJobRepository;
import com.ghas.vulnerabilityinsights.service.AsyncJobProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class EnterpriseJobService {

    private final EnterpriseJobRepository jobRepository;
    private final EnterpriseService enterpriseService;
    private final WebSocketMessageService webSocketService;
    private final AsyncJobProcessor asyncJobProcessor;
    private final ObjectMapper objectMapper;

    /**
     * Start a new job or return status of an existing one.
     */
    public JobStartResponseDto startJob(String enterpriseName, String githubToken) {
        log.info("Starting enterprise job for: {}", enterpriseName);
        
        // Check if there's already a running job for this enterprise
        Optional<EnterpriseJob> existingJob = jobRepository.findRunningJobForEnterprise(enterpriseName);
        if (existingJob.isPresent()) {
            log.info("Found existing running job for enterprise {}: {}", enterpriseName, existingJob.get().getId());
            return buildJobResponse(existingJob.get(), "Job already running for this enterprise", false);
        }
        
        // Check for recent completed results (within last 5 minutes) to potentially return cached data
        LocalDateTime cutoff = LocalDateTime.now().minusMinutes(5);
        Optional<EnterpriseJob> recentJob = jobRepository.findRecentCompletedJobs(enterpriseName, cutoff)
                .stream().findFirst();
        
        if (recentJob.isPresent()) {
            EnterpriseJob job = recentJob.get();
            log.info("Found recent completed job for enterprise {}: {}", enterpriseName, job.getId());
            log.info("Final results present: {}", job.getFinalResults() != null && !job.getFinalResults().trim().isEmpty());
            
            if (job.getFinalResults() != null && !job.getFinalResults().trim().isEmpty()) {
                log.info("Returning cached results for job: {}", job.getId());
                return buildJobResponseWithCache(job);
            } else {
                log.warn("Recent job found but no final results, will create new job");
            }
        }

        // Create new job
        String jobId = UUID.randomUUID().toString();
        EnterpriseJob job = EnterpriseJob.builder()
                .id(jobId)
                .enterpriseName(enterpriseName)
                .githubToken(githubToken) // Store the token for async processing
                .status(EnterpriseJob.JobStatus.PENDING)
                .progress(0)
                .codeScanningStatus(EnterpriseJob.TaskStatus.PENDING)
                .secretScanningStatus(EnterpriseJob.TaskStatus.PENDING)
                .dependabotStatus(EnterpriseJob.TaskStatus.PENDING)
                .estimatedDurationMinutes(5) // 3-5 minutes estimated
                .build();
        
        job = jobRepository.save(job);
        log.info("Created new enterprise job: {}", jobId);
        
        // Update job status to PROCESSING immediately before starting async work
        job.setStatus(EnterpriseJob.JobStatus.PROCESSING);
        job.setProgress(1);
        job = jobRepository.save(job);
        
        // Send initial WebSocket update to show progress bar
        webSocketService.sendJobProgressUpdate(jobId, convertToProgressUpdate(job));
        
        // Start processing asynchronously with correct function references
        asyncJobProcessor.processJob(
            jobId,
            token -> enterpriseService.getCodeScanningAlertsInternal(enterpriseName, token),
            token -> enterpriseService.getSecretScanningAlertsInternal(enterpriseName, token),
            token -> enterpriseService.getDependabotAlertsInternal(enterpriseName, token)
        );
        log.info("Dispatched job {} for async processing.", jobId);
        
        return buildJobResponse(job, "Job started successfully", false);
    }

    /**
     * Get current job status
     */
    public Optional<JobProgressUpdateDto> getJobStatus(String jobId) {
        return jobRepository.findById(jobId)
                .map(this::convertToProgressUpdate);
    }

    /**
     * Helper method to get the token for a job
     */
    public String getJobToken(String jobId) {
        return jobRepository.findById(jobId)
                .map(EnterpriseJob::getGithubToken)
                .orElseThrow(() -> new RuntimeException("Job not found or missing token: " + jobId));
    }

    /**
     * Convert job entity to progress update DTO
     */
    public JobProgressUpdateDto convertToProgressUpdate(EnterpriseJob job) {
        JobProgressUpdateDto.PartialResultsDto partialResults = null;
        
        try {
            if (job.getPartialResults() != null && !job.getPartialResults().trim().isEmpty()) {
                // Parse the JSON results and convert to DTO format
                Map<String, Object> resultsMap = objectMapper.readValue(job.getPartialResults(), Map.class);
                partialResults = JobProgressUpdateDto.PartialResultsDto.builder()
                        .codeScanning(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("codeScanning")))
                        .secretScanning(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("secretScanning")))
                        .dependabot(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("dependabot")))
                        .build();
            }
        } catch (Exception e) {
            log.warn("Failed to parse partial results for job {}: {}", job.getId(), e.getMessage());
        }
        
        // Determine current task based on job status and progress
        String currentTask = determineCurrentTask(job);
        
        return JobProgressUpdateDto.builder()
                .jobId(job.getId())
                .enterpriseName(job.getEnterpriseName())
                .status(JobProgressUpdateDto.JobStatus.valueOf(job.getStatus().name()))
                .progress(job.getProgress())
                .currentTask(currentTask)
                .codeScanningProgress(JobProgressUpdateDto.TaskProgress.builder()
                        .status(job.getCodeScanningStatus())
                        .build())
                .secretScanningProgress(JobProgressUpdateDto.TaskProgress.builder()
                        .status(job.getSecretScanningStatus())
                        .build())
                .dependabotProgress(JobProgressUpdateDto.TaskProgress.builder()
                        .status(job.getDependabotStatus())
                        .build())
                .partialResults(partialResults)
                .errorMessage(job.getErrorMessage())
                .createdAt(job.getCreatedAt())
                .estimatedCompletion(job.getCreatedAt().plusMinutes(job.getEstimatedDurationMinutes()))
                .build();
    }
    
    private JobProgressUpdateDto.VulnerabilityStatsDto parseVulnerabilityStats(Map<String, Object> stats) {
        if (stats == null) {
            return JobProgressUpdateDto.VulnerabilityStatsDto.builder()
                    .total(0).critical(0).high(0).medium(0).low(0).error(0)
                    .build();
        }
        
        return JobProgressUpdateDto.VulnerabilityStatsDto.builder()
                .total(getIntValue(stats, "total"))
                .critical(getIntValue(stats, "critical"))
                .high(getIntValue(stats, "high"))
                .medium(getIntValue(stats, "medium"))
                .low(getIntValue(stats, "low"))
                .error(getIntValue(stats, "error"))
                .build();
    }
    
    private int getIntValue(Map<String, Object> map, String key) {
        Object value = map.get(key);
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return 0;
    }
    
    private String determineCurrentTask(EnterpriseJob job) {
        if (job.getStatus() == EnterpriseJob.JobStatus.COMPLETED) {
            return "Scan completed successfully";
        } else if (job.getStatus() == EnterpriseJob.JobStatus.FAILED) {
            return "Scan failed: " + (job.getErrorMessage() != null ? job.getErrorMessage() : "Unknown error");
        } else if (job.getProgress() >= 95) {
            return "Finalizing results...";
        } else if (job.getProgress() >= 70) {
            return "Scanning for Dependabot vulnerabilities...";
        } else if (job.getProgress() >= 40) {
            return "Scanning for secret vulnerabilities...";
        } else if (job.getProgress() >= 10) {
            return "Scanning for code vulnerabilities...";
        } else {
            return "Initializing enterprise scan...";
        }
    }
    
    private JobStartResponseDto buildJobResponse(EnterpriseJob job, String message, boolean useCache) {
        return JobStartResponseDto.builder()
                .jobId(job.getId())
                .enterpriseName(job.getEnterpriseName())
                .status(job.getStatus().name())
                .message(message)
                .estimatedDurationMinutes(job.getEstimatedDurationMinutes())
                .websocketUrl("/topic/job/" + job.getId())
                .useExistingResults(useCache)
                .build();
    }
    
    private JobStartResponseDto buildJobResponseWithCache(EnterpriseJob job) {
        try {
            JobProgressUpdateDto.PartialResultsDto existingResults = null;
            if (job.getFinalResults() != null && !job.getFinalResults().trim().isEmpty()) {
                log.info("Parsing cached results for job: {}", job.getId());
                // Parse and convert existing results
                Map<String, Object> resultsMap = objectMapper.readValue(job.getFinalResults(), Map.class);
                existingResults = JobProgressUpdateDto.PartialResultsDto.builder()
                        .codeScanning(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("codeScanning")))
                        .secretScanning(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("secretScanning")))
                        .dependabot(parseVulnerabilityStats((Map<String, Object>) resultsMap.get("dependabot")))
                        .build();
                log.info("Successfully parsed cached results: {}", existingResults);
            } else {
                log.warn("No final results found for cached job: {}", job.getId());
            }
            
            return JobStartResponseDto.builder()
                    .jobId(job.getId())
                    .enterpriseName(job.getEnterpriseName())
                    .status("CACHED")
                    .message("Using recent results from " + job.getCompletedAt())
                    .estimatedDurationMinutes(0)
                    .websocketUrl("/topic/job/" + job.getId())
                    .useExistingResults(true)
                    .existingResults(existingResults)
                    .build();
                    
        } catch (Exception e) {
            log.error("Failed to build cached response: {}", e.getMessage());
            return buildJobResponse(job, "Found cached results but failed to parse", false);
        }
    }
    
}
